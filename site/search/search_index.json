{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"Introduction/","text":"Introduction to QueryStorm Welcome to the QueryStorm documentation. Here you will find an overview of the functionality that's included in QueryStorm and explain its core concepts. What is QueryStorm QueryStorm is an Excel add-in that brings first class support for modern programming languages (namely SQL, C# and VB.NET) into Excel. It is intended to enhance Excel's native functionality with a strong technical tool set. It has three main areas of use: Processing and migrating data using SQL and Linq Building and sharing custom Excel functions with SQL, C# and VB.NET Automating workbooks with with SQL, C# and VB.NET Who it's for The main audiences for QueryStorm can be split into three distinct groups: Data professionals , such as database specialists, data scientists and data analysts use it to facilitate processing of data in Excel, and moving data between Excel and databases. Developers too use if for processing data in Excel, but also for building custom Excel functions and workbook applications for their clients and users. Business users use it to make use of the custom functions and workbook applications that developers build for them. IDE and Runtime QueryStorm consists of two parts: the IDE and the Runtime . These are two separate add-ins that function independently. The IDE is a COM add-in, and the runtime is an XLL Excel add-in. The IDE is used by data professionals and developers for data processing and for creating custom functions and workbook applications. The Runtime is used by business users for installing and using those custom solutions. The full version of QueryStorm includes the IDE and the Runtime. A smaller runtime installer (and license) is available for use by business users.","title":"Introduction"},{"location":"Introduction/#introduction-to-querystorm","text":"Welcome to the QueryStorm documentation. Here you will find an overview of the functionality that's included in QueryStorm and explain its core concepts.","title":"Introduction to QueryStorm"},{"location":"Introduction/#what-is-querystorm","text":"QueryStorm is an Excel add-in that brings first class support for modern programming languages (namely SQL, C# and VB.NET) into Excel. It is intended to enhance Excel's native functionality with a strong technical tool set. It has three main areas of use: Processing and migrating data using SQL and Linq Building and sharing custom Excel functions with SQL, C# and VB.NET Automating workbooks with with SQL, C# and VB.NET","title":"What is QueryStorm"},{"location":"Introduction/#who-its-for","text":"The main audiences for QueryStorm can be split into three distinct groups: Data professionals , such as database specialists, data scientists and data analysts use it to facilitate processing of data in Excel, and moving data between Excel and databases. Developers too use if for processing data in Excel, but also for building custom Excel functions and workbook applications for their clients and users. Business users use it to make use of the custom functions and workbook applications that developers build for them.","title":"Who it's for"},{"location":"Introduction/#ide-and-runtime","text":"QueryStorm consists of two parts: the IDE and the Runtime . These are two separate add-ins that function independently. The IDE is a COM add-in, and the runtime is an XLL Excel add-in. The IDE is used by data professionals and developers for data processing and for creating custom functions and workbook applications. The Runtime is used by business users for installing and using those custom solutions. The full version of QueryStorm includes the IDE and the Runtime. A smaller runtime installer (and license) is available for use by business users.","title":"IDE and Runtime"},{"location":"1.%20Querying/1.%20Overview/","text":"Querying QueryStorm supports writing SQL and C# scripts that can see Excel tables, and work with data as if it was in a database (SQL) or in a .NET collection (C#). Tables, not sheets It's important to note that QueryStorm scripts work with Excel tables , and not with ranges or sheets. Press Ctr+T on a cell or a block of cells to convert it to a table. SQL querying QueryStorm comes with a built-in SQLite engine that can work with workbook tables as if they were regular database tables. You can run any valid SQLite query on your data, including UPDATE , INSERT and DELETE statements. Visit the SQLite section for more information. External databases Aside from the built-in SQLite engine, you can also connect to external databases. As you connect, you can choose which tables will be imported into the database as temp tables and thus made available to your scripts. This makes it easy to move data between Excel and databases. To connect to an external database, choose the appropriate script type in the ribbon. A dialog will appear allowing you to configure the connection and select the tables that should be included in the session as temp tables. Read more about working with external databases here . Querying with C# QueryStorm also allows querying data via C#. Tables are represented as collections of strongly typed objects that you can query and modify. Types that represent table rows are dynamically generated, allowing for strongly typed access to the data. Any changes you make to your workbook tables (e.g. adding a new column or a new table) are immediately reflected in your C# scripts. Read more about QueryStorm's C# scripting support here .","title":"Overview"},{"location":"1.%20Querying/1.%20Overview/#querying","text":"QueryStorm supports writing SQL and C# scripts that can see Excel tables, and work with data as if it was in a database (SQL) or in a .NET collection (C#).","title":"Querying"},{"location":"1.%20Querying/1.%20Overview/#tables-not-sheets","text":"It's important to note that QueryStorm scripts work with Excel tables , and not with ranges or sheets. Press Ctr+T on a cell or a block of cells to convert it to a table.","title":"Tables, not sheets"},{"location":"1.%20Querying/1.%20Overview/#sql-querying","text":"QueryStorm comes with a built-in SQLite engine that can work with workbook tables as if they were regular database tables. You can run any valid SQLite query on your data, including UPDATE , INSERT and DELETE statements. Visit the SQLite section for more information.","title":"SQL querying"},{"location":"1.%20Querying/1.%20Overview/#external-databases","text":"Aside from the built-in SQLite engine, you can also connect to external databases. As you connect, you can choose which tables will be imported into the database as temp tables and thus made available to your scripts. This makes it easy to move data between Excel and databases. To connect to an external database, choose the appropriate script type in the ribbon. A dialog will appear allowing you to configure the connection and select the tables that should be included in the session as temp tables. Read more about working with external databases here .","title":"External databases"},{"location":"1.%20Querying/1.%20Overview/#querying-with-c","text":"QueryStorm also allows querying data via C#. Tables are represented as collections of strongly typed objects that you can query and modify. Types that represent table rows are dynamically generated, allowing for strongly typed access to the data. Any changes you make to your workbook tables (e.g. adding a new column or a new table) are immediately reflected in your C# scripts. Read more about QueryStorm's C# scripting support here .","title":"Querying with C#"},{"location":"1.%20Querying/2.%20SQLite/","text":"SQLite QueryStorm comes equipped with a SQLite engine that can work with Excel tables as if they were database tables. Connecting Clicking the SQL button in the ribbon pops up the QueryStorm IDE and creates a new SQLite script that you can use to run queries against the tables in the current workbook. Querying Once connected, we can start querying. It's important to note that the SQLite engine will only see data inside Excel tables . Data that isn't marked as a table will not be visible. To turn a range into a table, select it and press Ctrl+T You can use SQL to query and modify data inside tables. All four SQL data operations are supported: select , insert , update and delete . Any changes that your commands make to the data inside workbook tables will be immediately visible in Excel. The __address column When using the SQLite engine, all workbook tables get an additional column named __address . This column contains the original address of the row in Excel. The __address column is hidden , meaning it is not included in the results if you only specify * in the select list; you must include it in the select list explicitly if you need it (e.g. select *, __address from... ). This column is useful for two main reasons: Double-clicking the address in the results grid will scroll to the range in Excel and select it The address information can be used for formatting ranges from SQL (described below) Querying cells While the SQLite engine primarily works with Excel tables, it can also work with cells via the xlcells() table-valued function. This is primarily useful when working with unstructured data. The following query returns a list of cells in the current selection: select * from xlcells () We can also return a list of cells in a specified range, like so: select * from xlcells ( 'Sheet1!B5:D9' ) Here's what the returned data looks like: For each cell in the selection, one row is returned in the results. Each cell is described with the following attributes: address , row , column , column letter , value , type , formula . We can use this information to search for cells that satisfy a particular criteria. Aside from reading, the xlcells function can also be used for updating cell values. In that case, xlcells is used as a table in the update query, and its parameter is specified in the where clause. For example, the following query will add 100 to all cells that have a numeric value: update XLCells -- referenced like a table set Value = Value + 100 where targetRangeAddress = 'H6:I8' -- the function's parameter is here (it's visible in autocomplete) and Type = 'Double' Under the hood, table-valued-functions in SQLite are implemented as virtual tables. Virtual tables can be referenced using the table syntax or the function syntax. When using the table syntax (as shown above), the function's parameters are specified in the WHERE clause. Formatting rows and cells Since the SQLite engine is running in-process with Excel, it can interact with Excel objects. A typical use case for this is modifying formatting. Two functions are provided for this purpose: SetBackgroundColor and ClearBackgroundColor . Here's an example: --first clear any previous formatting from the 'movies' table (the table name is used as the address) select ClearBackgroundColor ( 'movies' ); --apply new formatting to target rows select * , SetBackgroundColor ( __address , 'Orange' ) from movies where gross > 400000000 And the resulting formatting look like this: We can use the same approach to set the background color of individual cells: select ClearBackgroundColor ( 'a1:d10' ); select * , SetBackgroundColor ( Address , 'Orange' ) from xlcells ( 'a1:d10' ) x where x . Type = 'Double' Having the formatting functions in the select list might look peculiar. Formatting functions don't return any interesting results, but having them in the select list ensures that they have access to rows that satisfy the where clause. SQL was not designed for imperative code, so unfortunately, there isn't a more appropriate syntax for this. Indexing columns All columns of Excel tables are automatically indexed by the SQLite engine. This makes joins and searches very fast. However, all of the indexes are single-column indexes and no additional indexes can be defined by the user (for workbook tables). This is because QueryStorm uses SQLite's \"virtual table\" mechanism for representing workbook tables. Virtual tables have the indexing logic baked in and user defined indexes are not supported. If different indexing is needed, you can create a copy of the table and add indexes to the copy, though this is rarely required.","title":"SQLite"},{"location":"1.%20Querying/2.%20SQLite/#sqlite","text":"QueryStorm comes equipped with a SQLite engine that can work with Excel tables as if they were database tables.","title":"SQLite"},{"location":"1.%20Querying/2.%20SQLite/#connecting","text":"Clicking the SQL button in the ribbon pops up the QueryStorm IDE and creates a new SQLite script that you can use to run queries against the tables in the current workbook.","title":"Connecting"},{"location":"1.%20Querying/2.%20SQLite/#querying","text":"Once connected, we can start querying. It's important to note that the SQLite engine will only see data inside Excel tables . Data that isn't marked as a table will not be visible. To turn a range into a table, select it and press Ctrl+T You can use SQL to query and modify data inside tables. All four SQL data operations are supported: select , insert , update and delete . Any changes that your commands make to the data inside workbook tables will be immediately visible in Excel.","title":"Querying"},{"location":"1.%20Querying/2.%20SQLite/#the-__address-column","text":"When using the SQLite engine, all workbook tables get an additional column named __address . This column contains the original address of the row in Excel. The __address column is hidden , meaning it is not included in the results if you only specify * in the select list; you must include it in the select list explicitly if you need it (e.g. select *, __address from... ). This column is useful for two main reasons: Double-clicking the address in the results grid will scroll to the range in Excel and select it The address information can be used for formatting ranges from SQL (described below)","title":"The __address column"},{"location":"1.%20Querying/2.%20SQLite/#querying-cells","text":"While the SQLite engine primarily works with Excel tables, it can also work with cells via the xlcells() table-valued function. This is primarily useful when working with unstructured data. The following query returns a list of cells in the current selection: select * from xlcells () We can also return a list of cells in a specified range, like so: select * from xlcells ( 'Sheet1!B5:D9' ) Here's what the returned data looks like: For each cell in the selection, one row is returned in the results. Each cell is described with the following attributes: address , row , column , column letter , value , type , formula . We can use this information to search for cells that satisfy a particular criteria. Aside from reading, the xlcells function can also be used for updating cell values. In that case, xlcells is used as a table in the update query, and its parameter is specified in the where clause. For example, the following query will add 100 to all cells that have a numeric value: update XLCells -- referenced like a table set Value = Value + 100 where targetRangeAddress = 'H6:I8' -- the function's parameter is here (it's visible in autocomplete) and Type = 'Double' Under the hood, table-valued-functions in SQLite are implemented as virtual tables. Virtual tables can be referenced using the table syntax or the function syntax. When using the table syntax (as shown above), the function's parameters are specified in the WHERE clause.","title":"Querying cells"},{"location":"1.%20Querying/2.%20SQLite/#formatting-rows-and-cells","text":"Since the SQLite engine is running in-process with Excel, it can interact with Excel objects. A typical use case for this is modifying formatting. Two functions are provided for this purpose: SetBackgroundColor and ClearBackgroundColor . Here's an example: --first clear any previous formatting from the 'movies' table (the table name is used as the address) select ClearBackgroundColor ( 'movies' ); --apply new formatting to target rows select * , SetBackgroundColor ( __address , 'Orange' ) from movies where gross > 400000000 And the resulting formatting look like this: We can use the same approach to set the background color of individual cells: select ClearBackgroundColor ( 'a1:d10' ); select * , SetBackgroundColor ( Address , 'Orange' ) from xlcells ( 'a1:d10' ) x where x . Type = 'Double' Having the formatting functions in the select list might look peculiar. Formatting functions don't return any interesting results, but having them in the select list ensures that they have access to rows that satisfy the where clause. SQL was not designed for imperative code, so unfortunately, there isn't a more appropriate syntax for this.","title":"Formatting rows and cells"},{"location":"1.%20Querying/2.%20SQLite/#indexing-columns","text":"All columns of Excel tables are automatically indexed by the SQLite engine. This makes joins and searches very fast. However, all of the indexes are single-column indexes and no additional indexes can be defined by the user (for workbook tables). This is because QueryStorm uses SQLite's \"virtual table\" mechanism for representing workbook tables. Virtual tables have the indexing logic baked in and user defined indexes are not supported. If different indexing is needed, you can create a copy of the table and add indexes to the copy, though this is rarely required.","title":"Indexing columns"},{"location":"1.%20Querying/3.%20Databases/","text":"External databases QueryStorm supports connecting to external databases, allowing you to query workbook tables alongside database tables. This makes moving data between Excel and databases (in both directions) easy and convenient. Currently SQL Server, Postgres, MySql, SQLite and Redshift (via Postgres) are supported, while support for other databases may be rolled out in the future depending on user needs and requests. Querying To connect to a database, click the appropriate button from dropdown menu in the ribbon. QueryStorm will then prompt you to enter the connection details and select the workbook tables you would like to use in your script. When the connection is established, selected workbook tables are automatically copied to the database as temp tables. Once there, they can be queried or imported into permanent tables via SQL. While connected, any changes that you make to Excel tables are immediately synchronized to the temp tables. Aside from workbook tables, scripts can also see the values of named ranges. These can be used as parameters in your scripts: Only named ranges that refer to a single cell are usable as parameters. Getting data into Excel Query results can be written into the workbook as new tables or used to update existing ones. You can write the results of a query into a new or existing table by selecting a cell in Excel and pressing Alt+Insert (shortcut key for writing results). You can also output the results directly from the script, by using the SQL preprocessor , which is available to all SQL scripts in QueryStorm. For example, here's how to output the results of a query into an Excel table: { @ dpt } SELECT * FROM HumanResources . Department When this script is executed, the results of the select query will be written into an Excel table with the name dpt . If the table does not yet exist, it will be created starting at the currently selected cell. If a table called dpt does exists in the current workbook, it will be overwritten by the results of the query. If the workbook table has any columns that are not present in the query results (e.g. calculated columns), those columns will be left intact. To update multiple tables from the same script, we can use multiple output directives: { @ dpt } SELECT * FROM HumanResources . Department { @ people } SELECT * FROM Person . Person p Managing connection strings When entering connection details, you must give your connection string a name. The script file stores the connection name, while the actual connection string is stored in the module.config file: Referencing the connection string by name (instead of keeping it in the script file) lets scripts share connection strings. This makes it easier to e.g. redirect all scripts from a development database to a production database. Securing credentials Connection strings can contain sensitive data i.e. database credentials. It's usually not a good idea for developers to share their database credentials with end users. This is an important consideration when sharing the workbook itself or when building and sharing your own Excel SQL functions . For this reason, connection strings can be templated . Instead of the actual username and password, the developer puts placeholders inside the connection string. Two placeholders are supported: {username: id_of_the_credentials } {password} The placeholder for the username must provide the identifier of the credentials. The identifier is used for storing and retrieving the credentials. The following is an example of a templated connection string: Server=mssql6.mojsite.com,1555; Database=thingieq_AdventureWorks2014; User Id={username:my_creds_123}; Password={password} When a script attempts to connect using the above connection string, it will search for stored credentials with the id my_creds_123 . If it does not find them, the user will be prompted to enter them: The credentials are then inserted into the connection string instead of the placeholders and a connection attempt is made. If the attempt fails, the prompt reappears. If the attempt succeeds, the credentials are encrypted and stored in a local file for future use. Once the credentials are stored, they are used automatically in the future every time a connection is attempted with a connection string that uses the same credentials ID (e.g. my_creds_123 ). If a connection attempt fails in the future, the user will again be prompted for their credentials. Stored credentials are encrypted using the via the Windows Data Protection API and stored in a file in the user's AppData directory. Only the user that created the file can decrypt the data.","title":"Databases"},{"location":"1.%20Querying/3.%20Databases/#external-databases","text":"QueryStorm supports connecting to external databases, allowing you to query workbook tables alongside database tables. This makes moving data between Excel and databases (in both directions) easy and convenient. Currently SQL Server, Postgres, MySql, SQLite and Redshift (via Postgres) are supported, while support for other databases may be rolled out in the future depending on user needs and requests.","title":"External databases"},{"location":"1.%20Querying/3.%20Databases/#querying","text":"To connect to a database, click the appropriate button from dropdown menu in the ribbon. QueryStorm will then prompt you to enter the connection details and select the workbook tables you would like to use in your script. When the connection is established, selected workbook tables are automatically copied to the database as temp tables. Once there, they can be queried or imported into permanent tables via SQL. While connected, any changes that you make to Excel tables are immediately synchronized to the temp tables. Aside from workbook tables, scripts can also see the values of named ranges. These can be used as parameters in your scripts: Only named ranges that refer to a single cell are usable as parameters.","title":"Querying"},{"location":"1.%20Querying/3.%20Databases/#getting-data-into-excel","text":"Query results can be written into the workbook as new tables or used to update existing ones. You can write the results of a query into a new or existing table by selecting a cell in Excel and pressing Alt+Insert (shortcut key for writing results). You can also output the results directly from the script, by using the SQL preprocessor , which is available to all SQL scripts in QueryStorm. For example, here's how to output the results of a query into an Excel table: { @ dpt } SELECT * FROM HumanResources . Department When this script is executed, the results of the select query will be written into an Excel table with the name dpt . If the table does not yet exist, it will be created starting at the currently selected cell. If a table called dpt does exists in the current workbook, it will be overwritten by the results of the query. If the workbook table has any columns that are not present in the query results (e.g. calculated columns), those columns will be left intact. To update multiple tables from the same script, we can use multiple output directives: { @ dpt } SELECT * FROM HumanResources . Department { @ people } SELECT * FROM Person . Person p","title":"Getting data into Excel"},{"location":"1.%20Querying/3.%20Databases/#managing-connection-strings","text":"When entering connection details, you must give your connection string a name. The script file stores the connection name, while the actual connection string is stored in the module.config file: Referencing the connection string by name (instead of keeping it in the script file) lets scripts share connection strings. This makes it easier to e.g. redirect all scripts from a development database to a production database.","title":"Managing connection strings"},{"location":"1.%20Querying/3.%20Databases/#securing-credentials","text":"Connection strings can contain sensitive data i.e. database credentials. It's usually not a good idea for developers to share their database credentials with end users. This is an important consideration when sharing the workbook itself or when building and sharing your own Excel SQL functions . For this reason, connection strings can be templated . Instead of the actual username and password, the developer puts placeholders inside the connection string. Two placeholders are supported: {username: id_of_the_credentials } {password} The placeholder for the username must provide the identifier of the credentials. The identifier is used for storing and retrieving the credentials. The following is an example of a templated connection string: Server=mssql6.mojsite.com,1555; Database=thingieq_AdventureWorks2014; User Id={username:my_creds_123}; Password={password} When a script attempts to connect using the above connection string, it will search for stored credentials with the id my_creds_123 . If it does not find them, the user will be prompted to enter them: The credentials are then inserted into the connection string instead of the placeholders and a connection attempt is made. If the attempt fails, the prompt reappears. If the attempt succeeds, the credentials are encrypted and stored in a local file for future use. Once the credentials are stored, they are used automatically in the future every time a connection is attempted with a connection string that uses the same credentials ID (e.g. my_creds_123 ). If a connection attempt fails in the future, the user will again be prompted for their credentials. Stored credentials are encrypted using the via the Windows Data Protection API and stored in a file in the user's AppData directory. Only the user that created the file can decrypt the data.","title":"Securing credentials"},{"location":"1.%20Querying/4.%20CSharp/","text":"C# scripts In QueryStorm, user can write C# scripts that interact with the workbook and the data inside workbook tables. Scripts can query workbook tables using LINQ, interact with the Excel object model or perform other arbitrary tasks. Querying tables One of the main features C# scripts offer is the ability to query tables using LINQ. For each table in the workbook, a variable is provided that gives strongly typed access to the table data. QueryStorm uses the Reflection.Emit API to dynamically generate classes that represent table rows. This is done on-the-fly, so if you modify Excel tables, QueryStorm will immediately update the generated types. For example, suppose you have a workbook table named salaries that contains data about people's salaries. You could search for people whose salary is greater than 100,000 like so: salaries . Where ( s => s . TotalPay >= 100000 ) C# scripts can also update data in tables. To update a particular row, simply assign new values to its properties. A ForEach extension method is also available to make it easy to update rows in bulk: salaries . Where ( s => s . FirstName == \"Marty\" ) . ForEach ( s => s . TotalPay = s . TotalPay + 2000 ) Rows can also be deleted individually or in bulk: // individually (Delete single row) salaries . Single ( s => s . Id == 123 ). Delete () // in bulk (Delete many rows) salaries . Where ( s => s . TotalPay == 0 ). Delete () Finally, we can also add rows using AddRow and InsertRow methods: var row = salaries . AddRow (); row . Id = 123 ; row . TotalPay = 123456 ; Column names Table columns in Excel can have names that are not legal C# identifiers. When row properties are generated, characters that are not allowed in C# identifiers are replaced with underscores. For example, if the table has a column named Job Title , the corresponding property will be Job_Title : salaries . GroupBy ( s => s . Job_Title ) Rows also have an indexer property, that allows reading and writing property values by name. The indexer uses the original column name: dynamic jobTitle = row [ \"Job Title\" ] // The return type of the indexer is `dynamic`. Locating rows in Excel Aside from properties that correspond to columns, rows have an additional __address property that can be used to locate rows in Excel. It returns the Excel address of the row. Double-clicking the address in the results grid selects the row in Excel. Double-clicking the row header in the results grid will also select the range in Excel, provided the row contains a valid address. Formatting rows Aside from locating rows in Excel, the __address property can also be used for selectively formatting rows: salaries . Where ( s => s . JobTitle . ToLower (). Contains ( \"manager\" )) . Where ( s => s . TotalPay > 50000 ) . Format ( range => range . Interior . Color = 0 x00ffff ) // hex int (B/G/R) C# scripting syntax The scripting flavor of C# is supported by Roslyn (the C# compiler) and is slightly different from regular C#. Most of the standard C# syntax is valid in scripts, but scripts also allow a more relaxed syntax where you can evaluate expressions, without the ceremony of defining types and methods. For example, we can return the current date like so: DateTime . Now // do not terminate with ; The script will return the result of the last expression in the code, unless it is terminated with a semicolon . To return a value from a statement that is not the last statement in the script, an explicit return statement is required: return Add ( 1 , 2 ); public int Add ( int a , int b ) { return a + b ; } Referencing dlls A C# script is hosted inside a project. The project has a module.config file that specifies library and NuGet references. To use local dlls or NuGet packages in your C# scripts, simply add them to the host project. After adding the references to the project, the script needs to disconnect and reconnect to see the changes. Referencing project code The script can also see the classes that the containing project exposes. It's important to note that the script is not compiled with the project. Rather, it references the project's output dll, so it only sees public types that the project exposes. The project should be built (compiled) before the script can use its types. As with references, the script should disconnect and reconnect in order to see changes. Interacting with the workbook object Each C# script has a variable called ThisProject that references the project that contains it. Workbook projects expose a Workbook property that exposes the workbook COM object. From there, the user can interact with the workbook via Excel's COM API. var workbook = ThisProject . Workbook ; // e.g. return the path of the current workbook workbook . FullName","title":"C# scripts"},{"location":"1.%20Querying/4.%20CSharp/#c-scripts","text":"In QueryStorm, user can write C# scripts that interact with the workbook and the data inside workbook tables. Scripts can query workbook tables using LINQ, interact with the Excel object model or perform other arbitrary tasks.","title":"C# scripts"},{"location":"1.%20Querying/4.%20CSharp/#querying-tables","text":"One of the main features C# scripts offer is the ability to query tables using LINQ. For each table in the workbook, a variable is provided that gives strongly typed access to the table data. QueryStorm uses the Reflection.Emit API to dynamically generate classes that represent table rows. This is done on-the-fly, so if you modify Excel tables, QueryStorm will immediately update the generated types. For example, suppose you have a workbook table named salaries that contains data about people's salaries. You could search for people whose salary is greater than 100,000 like so: salaries . Where ( s => s . TotalPay >= 100000 ) C# scripts can also update data in tables. To update a particular row, simply assign new values to its properties. A ForEach extension method is also available to make it easy to update rows in bulk: salaries . Where ( s => s . FirstName == \"Marty\" ) . ForEach ( s => s . TotalPay = s . TotalPay + 2000 ) Rows can also be deleted individually or in bulk: // individually (Delete single row) salaries . Single ( s => s . Id == 123 ). Delete () // in bulk (Delete many rows) salaries . Where ( s => s . TotalPay == 0 ). Delete () Finally, we can also add rows using AddRow and InsertRow methods: var row = salaries . AddRow (); row . Id = 123 ; row . TotalPay = 123456 ;","title":"Querying tables"},{"location":"1.%20Querying/4.%20CSharp/#column-names","text":"Table columns in Excel can have names that are not legal C# identifiers. When row properties are generated, characters that are not allowed in C# identifiers are replaced with underscores. For example, if the table has a column named Job Title , the corresponding property will be Job_Title : salaries . GroupBy ( s => s . Job_Title ) Rows also have an indexer property, that allows reading and writing property values by name. The indexer uses the original column name: dynamic jobTitle = row [ \"Job Title\" ] // The return type of the indexer is `dynamic`.","title":"Column names"},{"location":"1.%20Querying/4.%20CSharp/#locating-rows-in-excel","text":"Aside from properties that correspond to columns, rows have an additional __address property that can be used to locate rows in Excel. It returns the Excel address of the row. Double-clicking the address in the results grid selects the row in Excel. Double-clicking the row header in the results grid will also select the range in Excel, provided the row contains a valid address.","title":"Locating rows in Excel"},{"location":"1.%20Querying/4.%20CSharp/#formatting-rows","text":"Aside from locating rows in Excel, the __address property can also be used for selectively formatting rows: salaries . Where ( s => s . JobTitle . ToLower (). Contains ( \"manager\" )) . Where ( s => s . TotalPay > 50000 ) . Format ( range => range . Interior . Color = 0 x00ffff ) // hex int (B/G/R)","title":"Formatting rows"},{"location":"1.%20Querying/4.%20CSharp/#c-scripting-syntax","text":"The scripting flavor of C# is supported by Roslyn (the C# compiler) and is slightly different from regular C#. Most of the standard C# syntax is valid in scripts, but scripts also allow a more relaxed syntax where you can evaluate expressions, without the ceremony of defining types and methods. For example, we can return the current date like so: DateTime . Now // do not terminate with ; The script will return the result of the last expression in the code, unless it is terminated with a semicolon . To return a value from a statement that is not the last statement in the script, an explicit return statement is required: return Add ( 1 , 2 ); public int Add ( int a , int b ) { return a + b ; }","title":"C# scripting syntax"},{"location":"1.%20Querying/4.%20CSharp/#referencing-dlls","text":"A C# script is hosted inside a project. The project has a module.config file that specifies library and NuGet references. To use local dlls or NuGet packages in your C# scripts, simply add them to the host project. After adding the references to the project, the script needs to disconnect and reconnect to see the changes.","title":"Referencing dlls"},{"location":"1.%20Querying/4.%20CSharp/#referencing-project-code","text":"The script can also see the classes that the containing project exposes. It's important to note that the script is not compiled with the project. Rather, it references the project's output dll, so it only sees public types that the project exposes. The project should be built (compiled) before the script can use its types. As with references, the script should disconnect and reconnect in order to see changes.","title":"Referencing project code"},{"location":"1.%20Querying/4.%20CSharp/#interacting-with-the-workbook-object","text":"Each C# script has a variable called ThisProject that references the project that contains it. Workbook projects expose a Workbook property that exposes the workbook COM object. From there, the user can interact with the workbook via Excel's COM API. var workbook = ThisProject . Workbook ; // e.g. return the path of the current workbook workbook . FullName","title":"Interacting with the workbook object"},{"location":"2.%20Custom%20Excel%20functions/1.%20Overview/","text":"Custom Excel functions QueryStorm enables user to add new functions to Excel. Users who use the full version of QueryStorm can build their own custom functions as well as publish them to other users. Users who use the Runtime version of QueryStorm can install packages published by creators, but cannot create their own functions. Two kinds of functions Functions can be defined inside a particular workbook or in an extension package . Functions in the workbook Functions that are defined inside a workbook are only available to that workbook. The advantage to this is that they will be immediately available to others when they open a copy of your workbook (provided they have the QueryStorm runtime), so you don't need to distribute them separately. Functions in an extension package Functions can also be defined in extension packages . Functions contained in an extension package are usable in any workbook on the machine. Authors can easily publish their extension packages to make them available to other (QueryStorm Runtime) users. Click here for more information about publishing extension packages. Supported languages QueryStorm lets you define new Excel functions using SQL , C# and VB.NET . Creating functions via SQL Defining functions in SQL is useful for returning data from databases. The function body is written in SQL, while the function declaration uses a simple preprocessor syntax that's available in all SQL scripts in QueryStorm. For example: -- the declaration of the function { function searchPeople ( string searchTerm = \"tim\" ) } -- the body of the function select * from Person . Person p where p . FirstName like '%' + @ searchTerm + '%' To read more about creating functions with SQL, click here . Creating functions via C# and VB.NET Building functions in C# and VB.NET is a matter of writing the code of the function and decorating it with the ExcelFunction attribute. The function might perform a calculation on its own, or it might call into some third party library or a REST service. For example: public class MyFunctions { [ExcelFunction] public static int Add ( int a , int b ) { return a + b ; } } The user can choose the language (C# or VB.NET) they wish to use in the module.config file. To read more about creating functions with C# and VB.NET, click here .","title":"Overview"},{"location":"2.%20Custom%20Excel%20functions/1.%20Overview/#custom-excel-functions","text":"QueryStorm enables user to add new functions to Excel. Users who use the full version of QueryStorm can build their own custom functions as well as publish them to other users. Users who use the Runtime version of QueryStorm can install packages published by creators, but cannot create their own functions.","title":"Custom Excel functions"},{"location":"2.%20Custom%20Excel%20functions/1.%20Overview/#two-kinds-of-functions","text":"Functions can be defined inside a particular workbook or in an extension package .","title":"Two kinds of functions"},{"location":"2.%20Custom%20Excel%20functions/1.%20Overview/#functions-in-the-workbook","text":"Functions that are defined inside a workbook are only available to that workbook. The advantage to this is that they will be immediately available to others when they open a copy of your workbook (provided they have the QueryStorm runtime), so you don't need to distribute them separately.","title":"Functions in the workbook"},{"location":"2.%20Custom%20Excel%20functions/1.%20Overview/#functions-in-an-extension-package","text":"Functions can also be defined in extension packages . Functions contained in an extension package are usable in any workbook on the machine. Authors can easily publish their extension packages to make them available to other (QueryStorm Runtime) users. Click here for more information about publishing extension packages.","title":"Functions in an extension package"},{"location":"2.%20Custom%20Excel%20functions/1.%20Overview/#supported-languages","text":"QueryStorm lets you define new Excel functions using SQL , C# and VB.NET .","title":"Supported languages"},{"location":"2.%20Custom%20Excel%20functions/1.%20Overview/#creating-functions-via-sql","text":"Defining functions in SQL is useful for returning data from databases. The function body is written in SQL, while the function declaration uses a simple preprocessor syntax that's available in all SQL scripts in QueryStorm. For example: -- the declaration of the function { function searchPeople ( string searchTerm = \"tim\" ) } -- the body of the function select * from Person . Person p where p . FirstName like '%' + @ searchTerm + '%' To read more about creating functions with SQL, click here .","title":"Creating functions via SQL"},{"location":"2.%20Custom%20Excel%20functions/1.%20Overview/#creating-functions-via-c-and-vbnet","text":"Building functions in C# and VB.NET is a matter of writing the code of the function and decorating it with the ExcelFunction attribute. The function might perform a calculation on its own, or it might call into some third party library or a REST service. For example: public class MyFunctions { [ExcelFunction] public static int Add ( int a , int b ) { return a + b ; } } The user can choose the language (C# or VB.NET) they wish to use in the module.config file. To read more about creating functions with C# and VB.NET, click here .","title":"Creating functions via C# and VB.NET"},{"location":"2.%20Custom%20Excel%20functions/2.%20Functions%20via%20SQL/","text":"Excel functions via SQL QueryStorm allows creating Excel functions that use SQL to return data from a database. The body of the function is written in SQL, while the declaration of the function uses a preprocessor syntax that's specific to QueryStorm. Suppose we'd like to define a function that returns a list of people from the database whose first name contains a specified search term. To define this function, we need to create a new script and connect to our target database. Once connected, we can use the following code to define and test the function: -- the declaration of the function { function searchPeople ( string searchTerm = \"tim\" ) } -- the body of the function select * from Person . Person p where FirstName like '%' + @ searchTerm + '%' We can run the code to examine if it returns the expected results. When running the query, the @searchTerm parameter's default value will be used. In this example, the query will return all persons whose name contains the string \"tim\" . Running the code simply runs the query, but does not register the function with Excel. To register this function with Excel, we must: Save the script [ Ctrl+S ] Build the project [ Ctrl+Shift+B ] For a video demonstration of the process, click below: Parameters Functions can accept parameters. Function parameters have names, types and default values. There are five supported data types for parameters: int , float , datetime , string and bool . The following are examples of valid parameter declarations: int abc = 123 float abc = 12.3 datetime abc = \"2020-08-31\" (ISO 8601 format) string abc = \"some text\" bool abc = true var abc = \"example text\" (auto-detect type) To reference a variable in the body of the SQL query, you can either use preprocessor expressions e.g. {abc} or the standard syntax for parameters, e.g. @abc (for SQL Server). A parameter's default value is only used when the query is directly executed. When the function is called from Excel, the default value of the parameter is ignored. Return values Functions can return a single value or an entire table as their result. If your machine (or the end user's machine) is running one of the newer (Office365) versions of Excel that support dynamic arrays , tabular results will automatically spill. If you are using an older version of Excel, you will need to use Ctrl+Alt+Enter (or {=function()} syntax) to allow the result to return a table of data (however, you'll need to know in advance the size of the output data). Sharing functions So once you've built the function, where can you use it? It depends on where you've created it. Functions can be defined inside a particular workbook or as a QueryStorm extension that's available in all workbooks. Functions defined in the workbook If the function is stored inside the workbook, anyone who has the workbook (and the QueryStorm runtime) will be able to use it. However, this function will only be usable in the workbook that contains it. If the function should be usable in any Excel file, you should define it in an \"Extension\" package (as described below) QueryStorm supports building extension projects which can contain a set of user defined Excel functions that can be packaged together and published to other users. To define the function in a QueryStorm extension rather than in the workbook, create a new project in \"Code explorer\" and then add a new script from the context menu of the new project. For a video demonstration of this process, click below:","title":"Functions via SQL"},{"location":"2.%20Custom%20Excel%20functions/2.%20Functions%20via%20SQL/#excel-functions-via-sql","text":"QueryStorm allows creating Excel functions that use SQL to return data from a database. The body of the function is written in SQL, while the declaration of the function uses a preprocessor syntax that's specific to QueryStorm. Suppose we'd like to define a function that returns a list of people from the database whose first name contains a specified search term. To define this function, we need to create a new script and connect to our target database. Once connected, we can use the following code to define and test the function: -- the declaration of the function { function searchPeople ( string searchTerm = \"tim\" ) } -- the body of the function select * from Person . Person p where FirstName like '%' + @ searchTerm + '%' We can run the code to examine if it returns the expected results. When running the query, the @searchTerm parameter's default value will be used. In this example, the query will return all persons whose name contains the string \"tim\" . Running the code simply runs the query, but does not register the function with Excel. To register this function with Excel, we must: Save the script [ Ctrl+S ] Build the project [ Ctrl+Shift+B ] For a video demonstration of the process, click below:","title":"Excel functions via SQL"},{"location":"2.%20Custom%20Excel%20functions/2.%20Functions%20via%20SQL/#parameters","text":"Functions can accept parameters. Function parameters have names, types and default values. There are five supported data types for parameters: int , float , datetime , string and bool . The following are examples of valid parameter declarations: int abc = 123 float abc = 12.3 datetime abc = \"2020-08-31\" (ISO 8601 format) string abc = \"some text\" bool abc = true var abc = \"example text\" (auto-detect type) To reference a variable in the body of the SQL query, you can either use preprocessor expressions e.g. {abc} or the standard syntax for parameters, e.g. @abc (for SQL Server). A parameter's default value is only used when the query is directly executed. When the function is called from Excel, the default value of the parameter is ignored.","title":"Parameters"},{"location":"2.%20Custom%20Excel%20functions/2.%20Functions%20via%20SQL/#return-values","text":"Functions can return a single value or an entire table as their result. If your machine (or the end user's machine) is running one of the newer (Office365) versions of Excel that support dynamic arrays , tabular results will automatically spill. If you are using an older version of Excel, you will need to use Ctrl+Alt+Enter (or {=function()} syntax) to allow the result to return a table of data (however, you'll need to know in advance the size of the output data).","title":"Return values"},{"location":"2.%20Custom%20Excel%20functions/2.%20Functions%20via%20SQL/#sharing-functions","text":"So once you've built the function, where can you use it? It depends on where you've created it. Functions can be defined inside a particular workbook or as a QueryStorm extension that's available in all workbooks.","title":"Sharing functions"},{"location":"2.%20Custom%20Excel%20functions/2.%20Functions%20via%20SQL/#functions-defined-in-the-workbook","text":"If the function is stored inside the workbook, anyone who has the workbook (and the QueryStorm runtime) will be able to use it. However, this function will only be usable in the workbook that contains it. If the function should be usable in any Excel file, you should define it in an \"Extension\" package (as described below) QueryStorm supports building extension projects which can contain a set of user defined Excel functions that can be packaged together and published to other users. To define the function in a QueryStorm extension rather than in the workbook, create a new project in \"Code explorer\" and then add a new script from the context menu of the new project. For a video demonstration of this process, click below:","title":"Functions defined in the workbook"},{"location":"2.%20Custom%20Excel%20functions/3.%20Functions%20via%20DotNet/","text":"Defining functions with .NET The process of defining a function with C# or VB.NET is simply a matter of writing the function and decorating it with the ExcelFunction attribute. public class MyFunctions { [ExcelFunction] public static int Add ( int a , int b ) { return a + b ; } } Once the project that contains the function is built (compiled), the runtime will automatically load it and make the function available in Excel. Depending on if the function is in a workbook or an extension project, the function will be available in the defining workbook or in all workbooks. For a video demonstration click below: Switching to VB.NET In the module.config file, there is a setting that sets the language of the project. To switch to VB.NET, change the following line: \"Language\" : \"CSharp\" ...to... \"Language\" : \"VisualBasic\" This will ensure that the project builds using the VB.NET compiler and uses class templates for VB.NET. Once that's done, you can add a new class file and write your function in VB.NET, for example: public Module MyFunctions1 <ExcelFunction> public function AddTwoNumbers(val1 As Int32, val2 As Int32) as int32 return val1 + val2 end function End Module Dependencies Simple functions that do not rely on any shared dependencies can be static and do everything on their own. However, a function might need to get hold of a particular service (e.g. an API object) in order to perform its calculation. That service might be expensive to create, so we would not want to create a new instance each time the function is evaluated. It would be better to have a single instance of the service which we would use in each function call. If the function relies on such dependencies, it should not be static. The constructor of the class that owns the function is executed only once (just before the first function call), so any expensive dependencies can be created there. If multiple functions should share the same dependency, the dependency should be registered centrally, in the IOC container in the App class (inside the App.cs file ). The constructor of the function's class can then request the service it by simply declaring it as a constructor argument (constructor injection). For example: In App.cs: public App ( IUnityContainer container ) : base ( container ) { // register the service as a singleton container . RegisterType < SomeService >( new ContainerControlledLifetimeManager ()); } In ExcelFunctions1.cs: public class ExcelFunctions1 { SomeService someService ; // request the service by adding a ctor argument public ExcelFunctions1 ( SomeService someService ) { this . someService = someService ; } [ExcelFunction] public int Add ( int a , int b ) { // use the service to perform the calculation return someService . Add ( a , b ); } } QueryStorm uses the Unity container for dependency injection. Some of QueryStorm's own services are available via the IOC container (e.g. IDialogService ), and you can freely use those as well. Debugging functions QueryStorm does not currently have a built-in debugger, but there are two static methods that help with debugging: Log() and Debug() . The Log() method The simplest way to debug issues is to use the Log(object obj) method to print values to the messages pane. The Log() method is contained in the QueryStorm.Core.DebugHelpers class. All class files that QueryStorm generates have a static using directive for that class, so you can use the Log method anywhere in your code, without qualifying it with the namespace or the class name. It's important to note that QueryStorm has two log viewers. One is part of the IDE, and the other is part of the Runtime (launched separately from the ribbon). The output of the Log() method will be visible in both places, so Runtime users will be able to see these messages. Attaching a debugger The Log() method is useful, but quite often a proper debugger is needed to track down tricky bugs. QueryStorm compiles code in a debugger-friendly way, so it's fairly easy to debug your code with an external debugger. To launch a debugger at a particular location in the source code, use the Debug() method. The Debug() method is also available anywhere in the code without prefixing it with the namespace or the class name, due to the using directive that's part of all code files generated by QueryStorm. If the local machine has Visual Studio installed, the Debug() method will launch Visual Studio, attach it to the process and stop the debugger at the current line. If a debugger is already attached, it will simply stop at the line with the Debug() call. If you do not have Visual Studio installed, you can use the small open source DNSpy debugger, attach it to the Excel process, and use the Debug() method to stop the debugger at the desired line in the code. ExcelDNA QueryStorm uses the popular ExcelDNA library for registering Excel functions. The functions you define can be simple synchronous functions as shown here, but they can also be asynchronous, accept and return tabular values, cache data internally and do other non-trivial things. More information on these topics, and many more, can be found in the following resources: ExcelDna Google group ExcelDna on StackOverflow ExcelDna wiki on GitHub","title":"Functions via DotNet"},{"location":"2.%20Custom%20Excel%20functions/3.%20Functions%20via%20DotNet/#defining-functions-with-net","text":"The process of defining a function with C# or VB.NET is simply a matter of writing the function and decorating it with the ExcelFunction attribute. public class MyFunctions { [ExcelFunction] public static int Add ( int a , int b ) { return a + b ; } } Once the project that contains the function is built (compiled), the runtime will automatically load it and make the function available in Excel. Depending on if the function is in a workbook or an extension project, the function will be available in the defining workbook or in all workbooks. For a video demonstration click below:","title":"Defining functions with .NET"},{"location":"2.%20Custom%20Excel%20functions/3.%20Functions%20via%20DotNet/#switching-to-vbnet","text":"In the module.config file, there is a setting that sets the language of the project. To switch to VB.NET, change the following line: \"Language\" : \"CSharp\" ...to... \"Language\" : \"VisualBasic\" This will ensure that the project builds using the VB.NET compiler and uses class templates for VB.NET. Once that's done, you can add a new class file and write your function in VB.NET, for example: public Module MyFunctions1 <ExcelFunction> public function AddTwoNumbers(val1 As Int32, val2 As Int32) as int32 return val1 + val2 end function End Module","title":"Switching to VB.NET"},{"location":"2.%20Custom%20Excel%20functions/3.%20Functions%20via%20DotNet/#dependencies","text":"Simple functions that do not rely on any shared dependencies can be static and do everything on their own. However, a function might need to get hold of a particular service (e.g. an API object) in order to perform its calculation. That service might be expensive to create, so we would not want to create a new instance each time the function is evaluated. It would be better to have a single instance of the service which we would use in each function call. If the function relies on such dependencies, it should not be static. The constructor of the class that owns the function is executed only once (just before the first function call), so any expensive dependencies can be created there. If multiple functions should share the same dependency, the dependency should be registered centrally, in the IOC container in the App class (inside the App.cs file ). The constructor of the function's class can then request the service it by simply declaring it as a constructor argument (constructor injection). For example: In App.cs: public App ( IUnityContainer container ) : base ( container ) { // register the service as a singleton container . RegisterType < SomeService >( new ContainerControlledLifetimeManager ()); } In ExcelFunctions1.cs: public class ExcelFunctions1 { SomeService someService ; // request the service by adding a ctor argument public ExcelFunctions1 ( SomeService someService ) { this . someService = someService ; } [ExcelFunction] public int Add ( int a , int b ) { // use the service to perform the calculation return someService . Add ( a , b ); } } QueryStorm uses the Unity container for dependency injection. Some of QueryStorm's own services are available via the IOC container (e.g. IDialogService ), and you can freely use those as well.","title":"Dependencies"},{"location":"2.%20Custom%20Excel%20functions/3.%20Functions%20via%20DotNet/#debugging-functions","text":"QueryStorm does not currently have a built-in debugger, but there are two static methods that help with debugging: Log() and Debug() .","title":"Debugging functions"},{"location":"2.%20Custom%20Excel%20functions/3.%20Functions%20via%20DotNet/#the-log-method","text":"The simplest way to debug issues is to use the Log(object obj) method to print values to the messages pane. The Log() method is contained in the QueryStorm.Core.DebugHelpers class. All class files that QueryStorm generates have a static using directive for that class, so you can use the Log method anywhere in your code, without qualifying it with the namespace or the class name. It's important to note that QueryStorm has two log viewers. One is part of the IDE, and the other is part of the Runtime (launched separately from the ribbon). The output of the Log() method will be visible in both places, so Runtime users will be able to see these messages.","title":"The Log() method"},{"location":"2.%20Custom%20Excel%20functions/3.%20Functions%20via%20DotNet/#attaching-a-debugger","text":"The Log() method is useful, but quite often a proper debugger is needed to track down tricky bugs. QueryStorm compiles code in a debugger-friendly way, so it's fairly easy to debug your code with an external debugger. To launch a debugger at a particular location in the source code, use the Debug() method. The Debug() method is also available anywhere in the code without prefixing it with the namespace or the class name, due to the using directive that's part of all code files generated by QueryStorm. If the local machine has Visual Studio installed, the Debug() method will launch Visual Studio, attach it to the process and stop the debugger at the current line. If a debugger is already attached, it will simply stop at the line with the Debug() call. If you do not have Visual Studio installed, you can use the small open source DNSpy debugger, attach it to the Excel process, and use the Debug() method to stop the debugger at the desired line in the code.","title":"Attaching a debugger"},{"location":"2.%20Custom%20Excel%20functions/3.%20Functions%20via%20DotNet/#exceldna","text":"QueryStorm uses the popular ExcelDNA library for registering Excel functions. The functions you define can be simple synchronous functions as shown here, but they can also be asynchronous, accept and return tabular values, cache data internally and do other non-trivial things. More information on these topics, and many more, can be found in the following resources: ExcelDna Google group ExcelDna on StackOverflow ExcelDna wiki on GitHub","title":"ExcelDNA"},{"location":"2.%20Custom%20Excel%20functions/4.%20Publishing%20functions/","text":"Publishing packages When an extension package is built (compiled), the functions it contains are immediately registered and available on the local machine. To make them available to other users, however, you need to publish the package. To publish an extensions package, follow these steps: Build the project Right-click on the project and select \"Publish\" Choose the feed to publish to Enter information about the package Managing feeds (sources) Before you can publish packages, though, you will likely need to set up a feed that you can publish to. QueryStorm supports publishing to a network share or to an online server. If you are distributing packages inside your network, a shared network folder would be a good place to store them. If you want to distribute packages to users outside of your local network (e.g. to your clients), you can publish the package to an online NuGet server, like Azure Artifacts ( instructions below ). In both cases, the feed needs to be added to your list of feeds before you can publish to it. The list of feeds is edited in the Package Manager or in the Extensions manager dialog as shown below. The dialog can be opened via the Extensions button in the QueryStorm ribbon, or via the Manage packages context menu for projects. Tab for managing sources (feeds) Button for editing the feed Feed url or path Feed content type (Packages, Extensions or Both) Both creators and consumers use the above dialog to edit their package feeds. Publishing to a network share Adding a network share as a source is fairly straightforward: Click the \"Add source\" button to add a new source Give the new source an arbitrary name Enter the path to the network share in the \"URL\" field Select \"QueryStorm Extensions\" in the \"Feed type\" field Once that's done, you can publish your packages to this source. No credentials are required for publishing to a network share. Publishing to Azure artifacts Azure Artifacts is a cloud-based package management solution that allows you to create and share NuGet packages via feeds that can be public or private. Setting up a feed takes just a few minutes and is free of charge. Currently, the free plan allows for up to 2GB of storage, which is enough for thousands of packages and should be more than enough for most organizations. Should you need more space, scaling is quite easy and fairly affordable as well. Creating the feed To create an Azure artifacts feed, follow the steps below: Go to http://dev.azure.com/ and create an account After signing in, create a new project ( public ) Select the Artifacts tab Click \"Create Feed\" and give the feed a name Click \"Connect to Feed\" Click \"Visual Studio\" and copy the source link Go to QueryStorm in Excel and add a new package source with the url from the previous step Creating credentials In order to be able to publish to this feed, you'll also need to set up a personal access token, which you can use as the password. To do so, follow these steps: Click on the user settings in the top right corner of the page (in the azure webpage) Select \"Personal Access Token\" Set token expiration date Grant the token full access Copy the generated token In QueryStorm, enter the token as the password of the new feed and your email address (that's associated with your Azure account) as the username That's it. You can now publish to your new feed! The only thing left to do is to share the feed URL with your users so they can add it to their list of sources. For a video of the entire process, please click below: Updating packages When publishing a new version of an existing package, make sure to increment the version number , otherwise the server will report a collision with the version that is already on the server. If the repository is a network share, though, there will be no version checks.","title":"Publishing functions"},{"location":"2.%20Custom%20Excel%20functions/4.%20Publishing%20functions/#publishing-packages","text":"When an extension package is built (compiled), the functions it contains are immediately registered and available on the local machine. To make them available to other users, however, you need to publish the package. To publish an extensions package, follow these steps: Build the project Right-click on the project and select \"Publish\" Choose the feed to publish to Enter information about the package","title":"Publishing packages"},{"location":"2.%20Custom%20Excel%20functions/4.%20Publishing%20functions/#managing-feeds-sources","text":"Before you can publish packages, though, you will likely need to set up a feed that you can publish to. QueryStorm supports publishing to a network share or to an online server. If you are distributing packages inside your network, a shared network folder would be a good place to store them. If you want to distribute packages to users outside of your local network (e.g. to your clients), you can publish the package to an online NuGet server, like Azure Artifacts ( instructions below ). In both cases, the feed needs to be added to your list of feeds before you can publish to it. The list of feeds is edited in the Package Manager or in the Extensions manager dialog as shown below. The dialog can be opened via the Extensions button in the QueryStorm ribbon, or via the Manage packages context menu for projects. Tab for managing sources (feeds) Button for editing the feed Feed url or path Feed content type (Packages, Extensions or Both) Both creators and consumers use the above dialog to edit their package feeds.","title":"Managing feeds (sources)"},{"location":"2.%20Custom%20Excel%20functions/4.%20Publishing%20functions/#publishing-to-a-network-share","text":"Adding a network share as a source is fairly straightforward: Click the \"Add source\" button to add a new source Give the new source an arbitrary name Enter the path to the network share in the \"URL\" field Select \"QueryStorm Extensions\" in the \"Feed type\" field Once that's done, you can publish your packages to this source. No credentials are required for publishing to a network share.","title":"Publishing to a network share"},{"location":"2.%20Custom%20Excel%20functions/4.%20Publishing%20functions/#publishing-to-azure-artifacts","text":"Azure Artifacts is a cloud-based package management solution that allows you to create and share NuGet packages via feeds that can be public or private. Setting up a feed takes just a few minutes and is free of charge. Currently, the free plan allows for up to 2GB of storage, which is enough for thousands of packages and should be more than enough for most organizations. Should you need more space, scaling is quite easy and fairly affordable as well.","title":"Publishing to Azure artifacts"},{"location":"2.%20Custom%20Excel%20functions/4.%20Publishing%20functions/#creating-the-feed","text":"To create an Azure artifacts feed, follow the steps below: Go to http://dev.azure.com/ and create an account After signing in, create a new project ( public ) Select the Artifacts tab Click \"Create Feed\" and give the feed a name Click \"Connect to Feed\" Click \"Visual Studio\" and copy the source link Go to QueryStorm in Excel and add a new package source with the url from the previous step","title":"Creating the feed"},{"location":"2.%20Custom%20Excel%20functions/4.%20Publishing%20functions/#creating-credentials","text":"In order to be able to publish to this feed, you'll also need to set up a personal access token, which you can use as the password. To do so, follow these steps: Click on the user settings in the top right corner of the page (in the azure webpage) Select \"Personal Access Token\" Set token expiration date Grant the token full access Copy the generated token In QueryStorm, enter the token as the password of the new feed and your email address (that's associated with your Azure account) as the username That's it. You can now publish to your new feed! The only thing left to do is to share the feed URL with your users so they can add it to their list of sources. For a video of the entire process, please click below:","title":"Creating credentials"},{"location":"2.%20Custom%20Excel%20functions/4.%20Publishing%20functions/#updating-packages","text":"When publishing a new version of an existing package, make sure to increment the version number , otherwise the server will report a collision with the version that is already on the server. If the repository is a network share, though, there will be no version checks.","title":"Updating packages"},{"location":"2.%20Custom%20Excel%20functions/5.%20Installing%20packages/","text":"Installing packages Extension packages are created and published from the QueryStorm IDE by package creators, and are installed and used from the QueryStorm Runtime by end users. An extension package contains one or more custom Excel functions. A typical scenario for QueryStorm extensions is as follows: A developer or a consultant uses the QueryStorm IDE to write a set of Excel functions (in C#, VB.NET or SQL) for a particular purpose Once they've prepared the functions, they publish the package that contains them to a feed End users install the package using the Extensions manager in the QueryStorm Runtime The end users then use the new functions in their Excel workbooks Managing NuGet sources Package creators publish packages to a feed. This is typically a feed that's owned by the package creator. In order to be able to browse packages that a creator has prepared, you must add their feed into your list of feeds. The creator is responsible for providing you the with the URL to their feed. Once you have the URL, you can add it to your list of feeds. The list of feeds is edited in the Extensions Manager dialog as shown below. Area for managing sources (feeds) Button for editing the feed Feed url or path Feed content type (Packages, Extensions or Both) Both creators and consumers use the above dialog to edit their package feeds.","title":"Installing packages"},{"location":"2.%20Custom%20Excel%20functions/5.%20Installing%20packages/#installing-packages","text":"Extension packages are created and published from the QueryStorm IDE by package creators, and are installed and used from the QueryStorm Runtime by end users. An extension package contains one or more custom Excel functions. A typical scenario for QueryStorm extensions is as follows: A developer or a consultant uses the QueryStorm IDE to write a set of Excel functions (in C#, VB.NET or SQL) for a particular purpose Once they've prepared the functions, they publish the package that contains them to a feed End users install the package using the Extensions manager in the QueryStorm Runtime The end users then use the new functions in their Excel workbooks","title":"Installing packages"},{"location":"2.%20Custom%20Excel%20functions/5.%20Installing%20packages/#managing-nuget-sources","text":"Package creators publish packages to a feed. This is typically a feed that's owned by the package creator. In order to be able to browse packages that a creator has prepared, you must add their feed into your list of feeds. The creator is responsible for providing you the with the URL to their feed. Once you have the URL, you can add it to your list of feeds. The list of feeds is edited in the Extensions Manager dialog as shown below. Area for managing sources (feeds) Button for editing the feed Feed url or path Feed content type (Packages, Extensions or Both) Both creators and consumers use the above dialog to edit their package feeds.","title":"Managing NuGet sources"},{"location":"3.%20Automating%20workbooks/1.%20Overview/","text":"Automating workbooks Excel files offer data storage capabilities and a flexible user interface for data entry and visualization. However, Excel files aren't just static documents containing data; they can also have behavior, in effect, making the workbook a hybrid between a document and an application. Out of the box, Microsoft Excel allows automating workbooks using VBA. While this works, VBA is quite old and hasn't kept up with the new programming paradigms and ecosystems. QueryStorm offers the ability to use modern programming languages and ecosystems when writing code to automate workbooks. This allows using C# or VB.NET code in workbooks, instead of VBA. It also allows using NuGet packages and existing .NET dlls inside Excel workbooks, making it easy to leverage your existing proprietary and 3rd party code in workbook applications. Model-binding A simple way to automate a workbook is to simply access Excel via it's COM API. While easy to get started with, writing code for interacting with the Excel API can get quite tedious. That's why QueryStorm offers a model-binding approach to automation, that minimizes the amount of Excel interaction code, and lets you focus on the logic of your application. SQL-based automation QueryStorm also allows setting up automation from SQL scripts. These scripts typically contain SQL code mixed in with a preprocessor syntax. The SQL code fetches data from the database, or updates data in a database. A preprocessor syntax is added to allow sending query results into the workbook, and to choose which events trigger the execution of the script. In actuality, all automation is done using C# or VB.NET, but under the hood, SQL scripts generate this code for you. This lets you focus on SQL, rather than on writing component code. It is also very useful for the many SQL users who are not familiar with .NET programming languages. Application lifetime QueryStorm workbook applications are started (by the QueryStorm runtime) as soon as the project is built, or when the workbook is opened. If we make changes and rebuild the project, the old instance of the application is unloaded and the new one is started.","title":"Overview"},{"location":"3.%20Automating%20workbooks/1.%20Overview/#automating-workbooks","text":"Excel files offer data storage capabilities and a flexible user interface for data entry and visualization. However, Excel files aren't just static documents containing data; they can also have behavior, in effect, making the workbook a hybrid between a document and an application. Out of the box, Microsoft Excel allows automating workbooks using VBA. While this works, VBA is quite old and hasn't kept up with the new programming paradigms and ecosystems. QueryStorm offers the ability to use modern programming languages and ecosystems when writing code to automate workbooks. This allows using C# or VB.NET code in workbooks, instead of VBA. It also allows using NuGet packages and existing .NET dlls inside Excel workbooks, making it easy to leverage your existing proprietary and 3rd party code in workbook applications.","title":"Automating workbooks"},{"location":"3.%20Automating%20workbooks/1.%20Overview/#model-binding","text":"A simple way to automate a workbook is to simply access Excel via it's COM API. While easy to get started with, writing code for interacting with the Excel API can get quite tedious. That's why QueryStorm offers a model-binding approach to automation, that minimizes the amount of Excel interaction code, and lets you focus on the logic of your application.","title":"Model-binding"},{"location":"3.%20Automating%20workbooks/1.%20Overview/#sql-based-automation","text":"QueryStorm also allows setting up automation from SQL scripts. These scripts typically contain SQL code mixed in with a preprocessor syntax. The SQL code fetches data from the database, or updates data in a database. A preprocessor syntax is added to allow sending query results into the workbook, and to choose which events trigger the execution of the script. In actuality, all automation is done using C# or VB.NET, but under the hood, SQL scripts generate this code for you. This lets you focus on SQL, rather than on writing component code. It is also very useful for the many SQL users who are not familiar with .NET programming languages.","title":"SQL-based automation"},{"location":"3.%20Automating%20workbooks/1.%20Overview/#application-lifetime","text":"QueryStorm workbook applications are started (by the QueryStorm runtime) as soon as the project is built, or when the workbook is opened. If we make changes and rebuild the project, the old instance of the application is unloaded and the new one is started.","title":"Application lifetime"},{"location":"3.%20Automating%20workbooks/2.%20Workbook%20automation%20with%20dotnet/","text":"Workbook automation with .NET QueryStorm allows using C# and VB.NET, instead of VBA, to automate Excel workbooks. It offers a model binding approach that is designed to minimize the amount of code that's needed to interact with Excel, although automation via the Excel COM API is also fully supported. Click below for a video example of the model-binding approach: Creating the project To automate the workbook, we must first add a project to it: This will create a project and prepare module.config and app.cs files that we can use as the starting point for out workbook application. When this project is built, the output files (.dll and .manifest) will be stored inside the workbook, and the runtime will automatically load the project. Each time an Excel workbook is opened, the QueryStorm runtime inspects it to see if there's a compiled workbook application inside it. If it finds one, it loads it along with the workbook. When the workbook is closed, the application is unloaded with it. The App class The workbook project has an App class that's defined in the App.cs (or App.vb ) file. This is the entry point of the application. In its constructor, we can request a WorkbookAccessor instance which will give us access to the workbook that contains the application. We can use the workbook object to read and write cell values, subscribe to events, refresh graphs and pivot tables etc. For example, we can pop up a message box each time a cell is selected (though admittedly, this is not a very useful thing to do): public App ( IUnityContainer container , IWorkbookAccessor workbookAccessor , IDialogService dialogService ) : base ( container ) { workbookAccessor . Workbook . SheetSelectionChange += ( sh , rng )=> { dialogService . ShowInfo ( $ \"Selected cell {rng.Address} with value '{rng.Value}'\" , \"\" , \"Selected cell changed\" ); }; } In most cases, however, it's better to leave Excel interactions to QueryStorm's model binding infrastructure, and only use the COM API in special cases. Dependency injection The constructor of the App class in the example above, accepts several parameters which are provided by the QueryStorm runtime via dependency injection. The workbookAccessor service is used to access the workbook, and the dialogService is used to display a message to the user. Each workbook application is provided (by the QueryStorm runtime) its own IOC container, which comes pre-populated with some basic services. It is the responsibility of the App class to register any additional services that other parts of the application might need. For example: public App ( IUnityContainer container ) : base ( container ) { // register a service (as a singleton) container . RegisterType < SomeService >( new ContainerControlledLifetimeManager ()); } The IOC container is used to create instances of other classes, such as the data context, components and function container classes, so all of those classes can accept dependencies via their constructors. For example: public class Component1 { public Component1 ( SomeService someService ) { // ... } } QueryStorm uses the Unity container for dependency injection. Components A component class contains logic that controls a section of the workbook. You can have any number of components in a workbook, each controlling it's own (arbitrarily defined) part of the workbook. Components have the following characteristics: They can accept dependencies via constructor injection. Public properties of a component can be data-bound to cells in Excel via the [Bind] attribute and to tables via the [BindTable] attribute. The methods of the component can handle events coming from Excel (e.g. button click), which is specified using the [EventHandler] attribute. For example, the following component reads a searchText parameter from a cell in Excel. Each time that parameter changes, it updates the names of people in a table, and writes a text into a messages cell: using System ; using System.Collections.Generic ; using System.Linq ; using System.Windows.Forms ; using QueryStorm.Core ; using static QueryStorm . Core . DebugHelpers ; namespace Project { public class Component1 : ComponentBase { [Bind(\"searchText\")] public string SearchText { get ; set ; } [BindTable] public People People { get ; set ; } private string _Message ; [Bind(\"messages\")] public string Message { get => _Message ; set { _Message = value ; OnPropertyChanged ( nameof ( Message )); } } [EventHandler(\"searchText\")] public void Test () { Message = $ \"Searched for '{SearchText}' at {DateTime.Now.ToShortTimeString()}\" ; People . ForEach ( t => { string nameWithoutStar = t . FirstName . TrimEnd ( '*' ); if ( t . FirstName . IndexOf ( SearchText , StringComparison . OrdinalIgnoreCase ) >= 0 ) t . FirstName = nameWithoutStar + \"*\" ; else t . FirstName = nameWithoutStar ; }); People . SaveChanges (); } } } And here is the resulting behavior: The important thing to note is that no part of the code interacts with Excel directly. The component only accesses its own properties, and the binding infrastructure takes care of communication with Excel. Bindings Bindings allow you to read and write values from Excel without having to access Excel objects directly or subscribe to their events to listen for changes. Bindings and the data context It's important to note that components aren't bound to Excel directly; they don't actually know anything about Excel. Instead, they are bound to a data context . For workbook applications, this data context happens to be a WorkbookDataContext instance that exposes data and events from the workbook. The data context allows you to customize the data that components (and scripts) see, to add relations between tables, as well as to create strongly typed classes for accessing table data. You can add a data context to the project from the project's context menu. Each time you save the data context file, strongly typed classes for tables will be generated under the data context file. These classes can then be used by components when binding to tables. Binding to cells Component properties can be bound to cells in Excel. This is achieved by using the [Bind(nameOfCell)] attribute. The attribute accepts a single parameter that specifies the name of the cell that should be bound to. By default, bindings work in both directions. When the user enters a new value into a bound cell, the property that the cell is bound to also gets updated. On the other hand, when a bound property's value changes (e.g. in an event handler), the component should raise a PropertyChanged event by calling e.g. OnPropertyChange(nameof(MyProperty123)) , which will in turn cause the cell value to update. Binding to tables A component's property can also bind to an Excel table, which is done using the [BindTable(tableName)] attribute. This allows the component to read and update table data. The type of the property should be the class that the data context generated for the table. That class is going to have the same name as the table in Excel. If you do not care about strongly typed access to the table, the type of the property can be Tabular . The Tabular class represent a table of data, but it's rows do not offer strongly typed access to the data. Instead, access to data is allowed via indexers (e.g. row[\"column_name\"] instead of row.column_name ). To update data in an Excel table, you simply update the data in the table instance and call table.SaveChanges() to commit changes to Excel. In C# scripts, SaveChanges() is called automatically, but in model-binding it needs to be explicit. Events Public methods of components can handle events coming in from the workbook. To do so, they need to be marked with the EventHandler attribute. Multiple EventHandler attributes can be applied to a method in order to handle multiple events. Currently, the following event sources are supported: ActiveX button (Click) Range (value changed) VBA (sent via the QueryStorm Runtime API) The event name, which is the single argument to the EventHandler attribute, determines which event the method handles. Handling button click events When a method needs to handle the click of a button, the following syntax should be used for the event name: {sheetName}!{buttonName} . For example, to handle the click of an ActiveX button named MyButton located on a sheet named Sheet1 , the method should be decorated as follows: [EventHandler(\"Sheet1!MyButton\")] public void MyEventHandlerMethod () { // ... } Handling range value changes When a method needs to be called every time a range changes, the name of the range should used as the event name: [EventHandler(\"nameOfTheCell\")] public void MyEventHandlerMethod () { // ... } Events from VBA Events can be sent from VBA code to the workbook application. One reason this might be useful is that it allows using regular buttons to send events, instead of ActiveX buttons which have known issues when changing resolution (e.g. second screen, projector). To send an event from VBA, use the QueryStorm.Runtime.API class, like so: CreateObject(\"QueryStorm.Runtime.API\").SendEvent(\"myEvent\") Instances of the QueryStorm.Runtime.API class are lightweight objects that forward messages to the QueryStorm Runtime. They carry no state and do not need to be cached.","title":"Workbook automation with dotnet"},{"location":"3.%20Automating%20workbooks/2.%20Workbook%20automation%20with%20dotnet/#workbook-automation-with-net","text":"QueryStorm allows using C# and VB.NET, instead of VBA, to automate Excel workbooks. It offers a model binding approach that is designed to minimize the amount of code that's needed to interact with Excel, although automation via the Excel COM API is also fully supported. Click below for a video example of the model-binding approach:","title":"Workbook automation with .NET"},{"location":"3.%20Automating%20workbooks/2.%20Workbook%20automation%20with%20dotnet/#creating-the-project","text":"To automate the workbook, we must first add a project to it: This will create a project and prepare module.config and app.cs files that we can use as the starting point for out workbook application. When this project is built, the output files (.dll and .manifest) will be stored inside the workbook, and the runtime will automatically load the project. Each time an Excel workbook is opened, the QueryStorm runtime inspects it to see if there's a compiled workbook application inside it. If it finds one, it loads it along with the workbook. When the workbook is closed, the application is unloaded with it.","title":"Creating the project"},{"location":"3.%20Automating%20workbooks/2.%20Workbook%20automation%20with%20dotnet/#the-app-class","text":"The workbook project has an App class that's defined in the App.cs (or App.vb ) file. This is the entry point of the application. In its constructor, we can request a WorkbookAccessor instance which will give us access to the workbook that contains the application. We can use the workbook object to read and write cell values, subscribe to events, refresh graphs and pivot tables etc. For example, we can pop up a message box each time a cell is selected (though admittedly, this is not a very useful thing to do): public App ( IUnityContainer container , IWorkbookAccessor workbookAccessor , IDialogService dialogService ) : base ( container ) { workbookAccessor . Workbook . SheetSelectionChange += ( sh , rng )=> { dialogService . ShowInfo ( $ \"Selected cell {rng.Address} with value '{rng.Value}'\" , \"\" , \"Selected cell changed\" ); }; } In most cases, however, it's better to leave Excel interactions to QueryStorm's model binding infrastructure, and only use the COM API in special cases.","title":"The App class"},{"location":"3.%20Automating%20workbooks/2.%20Workbook%20automation%20with%20dotnet/#dependency-injection","text":"The constructor of the App class in the example above, accepts several parameters which are provided by the QueryStorm runtime via dependency injection. The workbookAccessor service is used to access the workbook, and the dialogService is used to display a message to the user. Each workbook application is provided (by the QueryStorm runtime) its own IOC container, which comes pre-populated with some basic services. It is the responsibility of the App class to register any additional services that other parts of the application might need. For example: public App ( IUnityContainer container ) : base ( container ) { // register a service (as a singleton) container . RegisterType < SomeService >( new ContainerControlledLifetimeManager ()); } The IOC container is used to create instances of other classes, such as the data context, components and function container classes, so all of those classes can accept dependencies via their constructors. For example: public class Component1 { public Component1 ( SomeService someService ) { // ... } } QueryStorm uses the Unity container for dependency injection.","title":"Dependency injection"},{"location":"3.%20Automating%20workbooks/2.%20Workbook%20automation%20with%20dotnet/#components","text":"A component class contains logic that controls a section of the workbook. You can have any number of components in a workbook, each controlling it's own (arbitrarily defined) part of the workbook. Components have the following characteristics: They can accept dependencies via constructor injection. Public properties of a component can be data-bound to cells in Excel via the [Bind] attribute and to tables via the [BindTable] attribute. The methods of the component can handle events coming from Excel (e.g. button click), which is specified using the [EventHandler] attribute. For example, the following component reads a searchText parameter from a cell in Excel. Each time that parameter changes, it updates the names of people in a table, and writes a text into a messages cell: using System ; using System.Collections.Generic ; using System.Linq ; using System.Windows.Forms ; using QueryStorm.Core ; using static QueryStorm . Core . DebugHelpers ; namespace Project { public class Component1 : ComponentBase { [Bind(\"searchText\")] public string SearchText { get ; set ; } [BindTable] public People People { get ; set ; } private string _Message ; [Bind(\"messages\")] public string Message { get => _Message ; set { _Message = value ; OnPropertyChanged ( nameof ( Message )); } } [EventHandler(\"searchText\")] public void Test () { Message = $ \"Searched for '{SearchText}' at {DateTime.Now.ToShortTimeString()}\" ; People . ForEach ( t => { string nameWithoutStar = t . FirstName . TrimEnd ( '*' ); if ( t . FirstName . IndexOf ( SearchText , StringComparison . OrdinalIgnoreCase ) >= 0 ) t . FirstName = nameWithoutStar + \"*\" ; else t . FirstName = nameWithoutStar ; }); People . SaveChanges (); } } } And here is the resulting behavior: The important thing to note is that no part of the code interacts with Excel directly. The component only accesses its own properties, and the binding infrastructure takes care of communication with Excel.","title":"Components"},{"location":"3.%20Automating%20workbooks/2.%20Workbook%20automation%20with%20dotnet/#bindings","text":"Bindings allow you to read and write values from Excel without having to access Excel objects directly or subscribe to their events to listen for changes.","title":"Bindings"},{"location":"3.%20Automating%20workbooks/2.%20Workbook%20automation%20with%20dotnet/#bindings-and-the-data-context","text":"It's important to note that components aren't bound to Excel directly; they don't actually know anything about Excel. Instead, they are bound to a data context . For workbook applications, this data context happens to be a WorkbookDataContext instance that exposes data and events from the workbook. The data context allows you to customize the data that components (and scripts) see, to add relations between tables, as well as to create strongly typed classes for accessing table data. You can add a data context to the project from the project's context menu. Each time you save the data context file, strongly typed classes for tables will be generated under the data context file. These classes can then be used by components when binding to tables.","title":"Bindings and the data context"},{"location":"3.%20Automating%20workbooks/2.%20Workbook%20automation%20with%20dotnet/#binding-to-cells","text":"Component properties can be bound to cells in Excel. This is achieved by using the [Bind(nameOfCell)] attribute. The attribute accepts a single parameter that specifies the name of the cell that should be bound to. By default, bindings work in both directions. When the user enters a new value into a bound cell, the property that the cell is bound to also gets updated. On the other hand, when a bound property's value changes (e.g. in an event handler), the component should raise a PropertyChanged event by calling e.g. OnPropertyChange(nameof(MyProperty123)) , which will in turn cause the cell value to update.","title":"Binding to cells"},{"location":"3.%20Automating%20workbooks/2.%20Workbook%20automation%20with%20dotnet/#binding-to-tables","text":"A component's property can also bind to an Excel table, which is done using the [BindTable(tableName)] attribute. This allows the component to read and update table data. The type of the property should be the class that the data context generated for the table. That class is going to have the same name as the table in Excel. If you do not care about strongly typed access to the table, the type of the property can be Tabular . The Tabular class represent a table of data, but it's rows do not offer strongly typed access to the data. Instead, access to data is allowed via indexers (e.g. row[\"column_name\"] instead of row.column_name ). To update data in an Excel table, you simply update the data in the table instance and call table.SaveChanges() to commit changes to Excel. In C# scripts, SaveChanges() is called automatically, but in model-binding it needs to be explicit.","title":"Binding to tables"},{"location":"3.%20Automating%20workbooks/2.%20Workbook%20automation%20with%20dotnet/#events","text":"Public methods of components can handle events coming in from the workbook. To do so, they need to be marked with the EventHandler attribute. Multiple EventHandler attributes can be applied to a method in order to handle multiple events. Currently, the following event sources are supported: ActiveX button (Click) Range (value changed) VBA (sent via the QueryStorm Runtime API) The event name, which is the single argument to the EventHandler attribute, determines which event the method handles.","title":"Events"},{"location":"3.%20Automating%20workbooks/2.%20Workbook%20automation%20with%20dotnet/#handling-button-click-events","text":"When a method needs to handle the click of a button, the following syntax should be used for the event name: {sheetName}!{buttonName} . For example, to handle the click of an ActiveX button named MyButton located on a sheet named Sheet1 , the method should be decorated as follows: [EventHandler(\"Sheet1!MyButton\")] public void MyEventHandlerMethod () { // ... }","title":"Handling button click events"},{"location":"3.%20Automating%20workbooks/2.%20Workbook%20automation%20with%20dotnet/#handling-range-value-changes","text":"When a method needs to be called every time a range changes, the name of the range should used as the event name: [EventHandler(\"nameOfTheCell\")] public void MyEventHandlerMethod () { // ... }","title":"Handling range value changes"},{"location":"3.%20Automating%20workbooks/2.%20Workbook%20automation%20with%20dotnet/#events-from-vba","text":"Events can be sent from VBA code to the workbook application. One reason this might be useful is that it allows using regular buttons to send events, instead of ActiveX buttons which have known issues when changing resolution (e.g. second screen, projector). To send an event from VBA, use the QueryStorm.Runtime.API class, like so: CreateObject(\"QueryStorm.Runtime.API\").SendEvent(\"myEvent\") Instances of the QueryStorm.Runtime.API class are lightweight objects that forward messages to the QueryStorm Runtime. They carry no state and do not need to be cached.","title":"Events from VBA"},{"location":"3.%20Automating%20workbooks/3.%20Workbook%20automation%20with%20SQL/","text":"Automation via SQL Automation in QueryStorm is usually implemented by writing C# or VB.NET code inside component classes, as described in the previous chapters. However, this code does not necessarily need to be written by hand. SQL scripts can generate the component code automatically, which is especially useful for SQL users who are not familiar with C# and VB.NET. For this reason (among others) QueryStorm introduces a preprocessor for SQL scripts. When setting up automation this way, SQL code is used to fetch data and preprocessor code is used to specify when the script should be executed, and where the results should should be written to (e.g. an Excel table). Example Let's suppose we want to populate an Excel table with sales orders for a given date. When the value of the cell that contains the date changes, we want the script to execute again and to output the new results into the table. Here's how we might do that: { handles orderDate } { @ orders } select * from Sales . SalesOrderHeader soh where OrderDate = @ orderDate Starting the application In order to start the application, the script needs to be saved ( Ctrl+S ), and the project built ( Ctrl+Shift+B ). The component code is generated when the script is saved, and after the build, the runtime loads and activates the workbook application. Accessing workbook data The code in the example assumes that a cell called orderDate is defined in the workbook. The variable @orderDate that refers to this cell is made available to the script via the data context. Aside from giving cells names, no other special handling is required in order to be able to reference their values inside scripts. To allow the workbook to access Excel tables as well, the tables must be included when setting up the script via the \"Connect\" dialog. Outputting query results The preprocessor allows sending query results into Excel (via the data context). In the example above, the {@orders} output directive is used to send the results of the select query into an Excel table called orders . The syntax of the output directive is very simple: {@ table_name } or {output table_name } The output directive should be placed above the select query whose results it should output. If there are multiple select queries in the script, each of them can have its own output directive, so multiple tables can be updated from the same script. Events trigger execution Specifying events that should trigger execution is another job of the preprocessor. In the example above, we're using the orderDate event. For each named cell, an event with the same name is available that activates each time the cell value changes. In the example, using the cell name as the event, means that the script will execute each time the cell's value changes. To handle the click of an ActiveX button, we should use the following syntax: sheetName ! buttonName , for example {handles Sheet!CommandButton1} . Arbitrarily named events can also be sent from VBA and handled. To send an event from VBA, use the QueryStorm.Runtime.API class: CreateObject(\"QueryStorm.Runtime.API\").SendEvent(\"myEvent\") The event can be handled using the preprocessor like so: {handles myEvent} The script can handle multiple events. Event names should be separated by a comma: { handles myEvent , orderDate , Sheet1 ! CommandButton1 } { @ orders } select ... Commands vs functions `` The preprocessor syntax for declaring an automation command is as follows: { handles eventsList } This is shorthand for: { command commandName ( parametersList ) handles eventList } The command and function declarations are mutually exclusive. A script can either declare a command or a function, but not both. The functionality in the example looks like it should be implemented as a function that would accept a date parameter and return the query results. If the user's version of Excel supported dynamic arrays, the results could even automatically spill. Additionally, functions don't mess with Excel's undo functionality, which is another advantage for functions. The drawback of functions, however, is that the data returned from a function isn't an Excel table. The function results cannot be used as the contents of a table, so if you need to do any further processing on the data, the table is a much better place to store the results. Writing to a table can only be done from a command. For this example, since we're returning data from a database, we could have implemented this functionality either as a function or a command. However, if the script was updating database data rather than simply selecting data from it, implementing it as a command would be the only appropriate choice.","title":"Workbook automation with SQL"},{"location":"3.%20Automating%20workbooks/3.%20Workbook%20automation%20with%20SQL/#automation-via-sql","text":"Automation in QueryStorm is usually implemented by writing C# or VB.NET code inside component classes, as described in the previous chapters. However, this code does not necessarily need to be written by hand. SQL scripts can generate the component code automatically, which is especially useful for SQL users who are not familiar with C# and VB.NET. For this reason (among others) QueryStorm introduces a preprocessor for SQL scripts. When setting up automation this way, SQL code is used to fetch data and preprocessor code is used to specify when the script should be executed, and where the results should should be written to (e.g. an Excel table).","title":"Automation via SQL"},{"location":"3.%20Automating%20workbooks/3.%20Workbook%20automation%20with%20SQL/#example","text":"Let's suppose we want to populate an Excel table with sales orders for a given date. When the value of the cell that contains the date changes, we want the script to execute again and to output the new results into the table. Here's how we might do that: { handles orderDate } { @ orders } select * from Sales . SalesOrderHeader soh where OrderDate = @ orderDate","title":"Example"},{"location":"3.%20Automating%20workbooks/3.%20Workbook%20automation%20with%20SQL/#starting-the-application","text":"In order to start the application, the script needs to be saved ( Ctrl+S ), and the project built ( Ctrl+Shift+B ). The component code is generated when the script is saved, and after the build, the runtime loads and activates the workbook application.","title":"Starting the application"},{"location":"3.%20Automating%20workbooks/3.%20Workbook%20automation%20with%20SQL/#accessing-workbook-data","text":"The code in the example assumes that a cell called orderDate is defined in the workbook. The variable @orderDate that refers to this cell is made available to the script via the data context. Aside from giving cells names, no other special handling is required in order to be able to reference their values inside scripts. To allow the workbook to access Excel tables as well, the tables must be included when setting up the script via the \"Connect\" dialog.","title":"Accessing workbook data"},{"location":"3.%20Automating%20workbooks/3.%20Workbook%20automation%20with%20SQL/#outputting-query-results","text":"The preprocessor allows sending query results into Excel (via the data context). In the example above, the {@orders} output directive is used to send the results of the select query into an Excel table called orders . The syntax of the output directive is very simple: {@ table_name } or {output table_name } The output directive should be placed above the select query whose results it should output. If there are multiple select queries in the script, each of them can have its own output directive, so multiple tables can be updated from the same script.","title":"Outputting query results"},{"location":"3.%20Automating%20workbooks/3.%20Workbook%20automation%20with%20SQL/#events-trigger-execution","text":"Specifying events that should trigger execution is another job of the preprocessor. In the example above, we're using the orderDate event. For each named cell, an event with the same name is available that activates each time the cell value changes. In the example, using the cell name as the event, means that the script will execute each time the cell's value changes. To handle the click of an ActiveX button, we should use the following syntax: sheetName ! buttonName , for example {handles Sheet!CommandButton1} . Arbitrarily named events can also be sent from VBA and handled. To send an event from VBA, use the QueryStorm.Runtime.API class: CreateObject(\"QueryStorm.Runtime.API\").SendEvent(\"myEvent\") The event can be handled using the preprocessor like so: {handles myEvent} The script can handle multiple events. Event names should be separated by a comma: { handles myEvent , orderDate , Sheet1 ! CommandButton1 } { @ orders } select ...","title":"Events trigger execution"},{"location":"3.%20Automating%20workbooks/3.%20Workbook%20automation%20with%20SQL/#commands-vs-functions","text":"`` The preprocessor syntax for declaring an automation command is as follows: { handles eventsList } This is shorthand for: { command commandName ( parametersList ) handles eventList } The command and function declarations are mutually exclusive. A script can either declare a command or a function, but not both. The functionality in the example looks like it should be implemented as a function that would accept a date parameter and return the query results. If the user's version of Excel supported dynamic arrays, the results could even automatically spill. Additionally, functions don't mess with Excel's undo functionality, which is another advantage for functions. The drawback of functions, however, is that the data returned from a function isn't an Excel table. The function results cannot be used as the contents of a table, so if you need to do any further processing on the data, the table is a much better place to store the results. Writing to a table can only be done from a command. For this example, since we're returning data from a database, we could have implemented this functionality either as a function or a command. However, if the script was updating database data rather than simply selecting data from it, implementing it as a command would be the only appropriate choice.","title":"Commands vs functions"},{"location":"4.%20General%20topics/DataContext/","text":"The data context A data context exposes tables, variables and events to your scripts and components. When you create a script, a new instance of the data context is automatically created and passed to the script. The script gets all of its data from the data context, so it can only see tables and variables that the data context provides. In each project there is exactly one data context class. You can define your own data context class to customize the data that will be available to your scripts and components, but if not, a default data context will be used. The WorkbookDataContext For workbook projects that do not define a data context, a WorkbookDataContext is used by default. A WorkbookDataContext instance exposes data from a particular workbook in the following way: Tables = Excel tables Variables = Single-cell named ranges Events = workbook events (e.g. button click) Custom data context Overriding the data context allows you to: Add additional tables Change column data types Add relations between tables To define a data context class, right click on the project node and click \"Add\"=>\"DataContext class\". QueryStorm's data context works much like an object-relational mapper. The data context class specifies the tables and relations that will be available to user code. Strongly typed classes (that represent table rows) are generated behind the scenes each time the data context file is saved. Adding tables To include additional tables in the data context, add them to the Tables collection inside the Initialize method, as shown below: protected override void Initialize ( ContextSchema schema ) { // an example table var myFilesTbl = new TabularValue ( System . IO . Directory . GetFiles ( Environment . GetFolderPath ( Environment . SpecialFolder . MyDocuments ) ) , \"myFiles\" ); // add it to the context Tables . Add ( myFilesTbl ); base . Initialize ( schema ); } The DataContext.Tables collection contains objects that derive from the abstract class Tabular . You can choose from the existing implementations of Tabular , or create your own. For example, TabularValue is a versatile implementation that accepts any object (usually a collection) and exposes its values as a table. Changing column data types Excel does not enforce consistent column types, so the data context has to guess at their types based on their content. For example, suppose a column contains the numbers 1,2 and 3 . The auto-detect mechanism sees that the column contains numbers, but it does not know if the column is allowed to contain nulls or floating point numbers so it selects double? as the data type. To specify the column type explicitly, use the schema object in the Initialize method as shown below: protected override void Initialize ( ContextSchema schema ) { schema . ConfigureTable ( \"Person\" ) . ConfigureColumn < System . Int32 >( \"Id\" ) . ConfigureColumn < System . String >( \"Name\" ) . ConfigureColumn < System . DateTime >( \"DateOfBirth\" ); base . Initialize ( schema ); } Table relations Excel also doesn't offer a way to define relationships between tables, but you can define those relationships inside a data context class. Each time the data context file is saved, it is automatically compiled and loaded by the IDE, and strongly typed classes are generated based on the tables it offers. Specifying relationships between tables, ensures that you get strongly typed navigation properties on those classes. This does not impact SQL scripts but it does impact component code as well as C# scripts. To add table relations, use the schema object in the Initialize method as shown below: protected override void Initialize ( ContextSchema schema ) { schema . ConfigureTable ( \"Departments\" ) . ConfigureColumn < System . Int32 >( \"Id\" ) . ConfigureColumn < System . String >( \"Name\" ); schema . ConfigureTable ( \"Employees\" ) . ConfigureColumn < System . Int32 >( \"Id\" ) . ConfigureColumn < System . String >( \"FirstName\" ) . ConfigureColumn < System . Int32 >( \"DptId\" ) // adding a relation from Employees.DptId to Departments.Id . AddRelation ( \"DptId\" , To . One , \"Departments\" , \"Id\" , \"MyDepartment\" ); base . Initialize ( schema ); } Once the project is compiled, C# scripts will be able to use the new property MyDepartment on the employee objects. Tip: for performance reasons (to avoid type conversions), it's slightly better to leave Id columns as double instead of int . This is because Excel does not have an int type; all numbers in Excel are double . Demo Click below for a video demonstration of the concepts discussed in this segment:","title":"DataContext"},{"location":"4.%20General%20topics/DataContext/#the-data-context","text":"A data context exposes tables, variables and events to your scripts and components. When you create a script, a new instance of the data context is automatically created and passed to the script. The script gets all of its data from the data context, so it can only see tables and variables that the data context provides. In each project there is exactly one data context class. You can define your own data context class to customize the data that will be available to your scripts and components, but if not, a default data context will be used.","title":"The data context"},{"location":"4.%20General%20topics/DataContext/#the-workbookdatacontext","text":"For workbook projects that do not define a data context, a WorkbookDataContext is used by default. A WorkbookDataContext instance exposes data from a particular workbook in the following way: Tables = Excel tables Variables = Single-cell named ranges Events = workbook events (e.g. button click)","title":"The WorkbookDataContext"},{"location":"4.%20General%20topics/DataContext/#custom-data-context","text":"Overriding the data context allows you to: Add additional tables Change column data types Add relations between tables To define a data context class, right click on the project node and click \"Add\"=>\"DataContext class\". QueryStorm's data context works much like an object-relational mapper. The data context class specifies the tables and relations that will be available to user code. Strongly typed classes (that represent table rows) are generated behind the scenes each time the data context file is saved.","title":"Custom data context"},{"location":"4.%20General%20topics/DataContext/#adding-tables","text":"To include additional tables in the data context, add them to the Tables collection inside the Initialize method, as shown below: protected override void Initialize ( ContextSchema schema ) { // an example table var myFilesTbl = new TabularValue ( System . IO . Directory . GetFiles ( Environment . GetFolderPath ( Environment . SpecialFolder . MyDocuments ) ) , \"myFiles\" ); // add it to the context Tables . Add ( myFilesTbl ); base . Initialize ( schema ); } The DataContext.Tables collection contains objects that derive from the abstract class Tabular . You can choose from the existing implementations of Tabular , or create your own. For example, TabularValue is a versatile implementation that accepts any object (usually a collection) and exposes its values as a table.","title":"Adding tables"},{"location":"4.%20General%20topics/DataContext/#changing-column-data-types","text":"Excel does not enforce consistent column types, so the data context has to guess at their types based on their content. For example, suppose a column contains the numbers 1,2 and 3 . The auto-detect mechanism sees that the column contains numbers, but it does not know if the column is allowed to contain nulls or floating point numbers so it selects double? as the data type. To specify the column type explicitly, use the schema object in the Initialize method as shown below: protected override void Initialize ( ContextSchema schema ) { schema . ConfigureTable ( \"Person\" ) . ConfigureColumn < System . Int32 >( \"Id\" ) . ConfigureColumn < System . String >( \"Name\" ) . ConfigureColumn < System . DateTime >( \"DateOfBirth\" ); base . Initialize ( schema ); }","title":"Changing column data types"},{"location":"4.%20General%20topics/DataContext/#table-relations","text":"Excel also doesn't offer a way to define relationships between tables, but you can define those relationships inside a data context class. Each time the data context file is saved, it is automatically compiled and loaded by the IDE, and strongly typed classes are generated based on the tables it offers. Specifying relationships between tables, ensures that you get strongly typed navigation properties on those classes. This does not impact SQL scripts but it does impact component code as well as C# scripts. To add table relations, use the schema object in the Initialize method as shown below: protected override void Initialize ( ContextSchema schema ) { schema . ConfigureTable ( \"Departments\" ) . ConfigureColumn < System . Int32 >( \"Id\" ) . ConfigureColumn < System . String >( \"Name\" ); schema . ConfigureTable ( \"Employees\" ) . ConfigureColumn < System . Int32 >( \"Id\" ) . ConfigureColumn < System . String >( \"FirstName\" ) . ConfigureColumn < System . Int32 >( \"DptId\" ) // adding a relation from Employees.DptId to Departments.Id . AddRelation ( \"DptId\" , To . One , \"Departments\" , \"Id\" , \"MyDepartment\" ); base . Initialize ( schema ); } Once the project is compiled, C# scripts will be able to use the new property MyDepartment on the employee objects. Tip: for performance reasons (to avoid type conversions), it's slightly better to leave Id columns as double instead of int . This is because Excel does not have an int type; all numbers in Excel are double .","title":"Table relations"},{"location":"4.%20General%20topics/DataContext/#demo","text":"Click below for a video demonstration of the concepts discussed in this segment:","title":"Demo"},{"location":"4.%20General%20topics/Licensing/","text":"Licensing License types Full Includes runtime Lite Runtime Managing license keys Subscriptions Volume discounts","title":"Licensing"},{"location":"4.%20General%20topics/Licensing/#licensing","text":"","title":"Licensing"},{"location":"4.%20General%20topics/Licensing/#license-types","text":"","title":"License types"},{"location":"4.%20General%20topics/Licensing/#full","text":"Includes runtime","title":"Full"},{"location":"4.%20General%20topics/Licensing/#lite","text":"","title":"Lite"},{"location":"4.%20General%20topics/Licensing/#runtime","text":"","title":"Runtime"},{"location":"4.%20General%20topics/Licensing/#managing-license-keys","text":"","title":"Managing license keys"},{"location":"4.%20General%20topics/Licensing/#subscriptions","text":"","title":"Subscriptions"},{"location":"4.%20General%20topics/Licensing/#volume-discounts","text":"","title":"Volume discounts"},{"location":"4.%20General%20topics/Managing%20packages/","text":"Managing packages QueryStorm comes with NuGet support, which serves two purposes: Installing NuGet packages into projects Sharing QueryStorm extension packages NuGet packages The package manager is used for managing NuGet packages in QueryStorm projects (viewing, installing, uninstalling, updating). Installing a package into your project does the following: Adds an entry in the Dependencies section of the module.config file Downloads the package Unpacks the contents of the package into the project All dll files contained inside the package are unpacked into the lib folder and are automatically referenced. Since the package contents get stored inside the project, installing NuGet packages into a workbook project will increase the size of the workbook file. Most NuGet packages are fairly small, however, so the increase in size is unlikely to be an issue. The advantage to this is that workbook applications are self-contained and will run on any machine that has the QueryStorm runtime.","title":"Managing packages"},{"location":"4.%20General%20topics/Managing%20packages/#managing-packages","text":"QueryStorm comes with NuGet support, which serves two purposes: Installing NuGet packages into projects Sharing QueryStorm extension packages","title":"Managing packages"},{"location":"4.%20General%20topics/Managing%20packages/#nuget-packages","text":"The package manager is used for managing NuGet packages in QueryStorm projects (viewing, installing, uninstalling, updating). Installing a package into your project does the following: Adds an entry in the Dependencies section of the module.config file Downloads the package Unpacks the contents of the package into the project All dll files contained inside the package are unpacked into the lib folder and are automatically referenced. Since the package contents get stored inside the project, installing NuGet packages into a workbook project will increase the size of the workbook file. Most NuGet packages are fairly small, however, so the increase in size is unlikely to be an issue. The advantage to this is that workbook applications are self-contained and will run on any machine that has the QueryStorm runtime.","title":"NuGet packages"},{"location":"4.%20General%20topics/Preprocessor/","text":"The SQL Preprocessor QueryStorm introduces a simple preprocessor that's available in all SQL scripts in QueryStorm. The preprocessor adds the following capabilities to SQL scripts: Use values from Excel as parameters Define Excel functions Define Excel commands Output results into Excel Parameterized queries md Referencing cells For example, let's assume cell A1 in Sheet1 contains the value 3: select * from people where id = { Sheet1 ! A1 } The following query will be passed on to the underlying database engine: select * from people where id = 3 Here's how QueryStorm expressions are processed: 1. Evaluate expression 1. If result value is a string, surround it with single quotes 1. Replace the preprocessor expression in the query with the results 1. Once all expressions are processed, pass the updated query on to the underlying engine Preprocessor variables Additionally, it's also possible to define variables inside queries. This helps reduce magic constants and repetition, as well as making it easier to run the query with different inputs. Here's an example: : { myVariable = 123 } select * from people where id = { myVariable } The following is sent to the underlying database engine: select * from people where id = 123 Redirecting results The second important task of the preprocessor is redirecting query results into Excel tables and ranges. This can come in very handy for automation. For this purpose QueryStorm's preprocessor provides \" @-directives \". Here's an example: { @ OverdueBooks } select BookName , PersonName from BookRentals where ReturnDate < date () and Returned = 0 Running this query will immediately update the OverdueBooks table in Excel with the results. This saves time if we're working on a query and always writing the results into the same Excel table, but more importantly, it enables automatic update of an Excel table if we embed the query and set up appropriate triggers for executing it (automation). Multiple queries and redirects It is possible to have multiple select statements within a query, each one outputting results into a different table or range. Example: @ Table TableName = \"LargestCities\" select * from cities order by population descending limit 10 @ Table TableName = \"SmallestCities\" select * from cities order by population limit 10 Running this query will update two excel tables ( LargestCities and SmallestCities ) in one go. For automation scenarios, this can save time and bandwidth as the same connection (session) can be used to update multiple tables.","title":"Preprocessor"},{"location":"4.%20General%20topics/Preprocessor/#the-sql-preprocessor","text":"QueryStorm introduces a simple preprocessor that's available in all SQL scripts in QueryStorm. The preprocessor adds the following capabilities to SQL scripts: Use values from Excel as parameters Define Excel functions Define Excel commands Output results into Excel","title":"The SQL Preprocessor"},{"location":"4.%20General%20topics/Preprocessor/#parameterized-queries","text":"md","title":"Parameterized queries"},{"location":"4.%20General%20topics/Preprocessor/#referencing-cells","text":"For example, let's assume cell A1 in Sheet1 contains the value 3: select * from people where id = { Sheet1 ! A1 } The following query will be passed on to the underlying database engine: select * from people where id = 3 Here's how QueryStorm expressions are processed: 1. Evaluate expression 1. If result value is a string, surround it with single quotes 1. Replace the preprocessor expression in the query with the results 1. Once all expressions are processed, pass the updated query on to the underlying engine","title":"Referencing cells"},{"location":"4.%20General%20topics/Preprocessor/#preprocessor-variables","text":"Additionally, it's also possible to define variables inside queries. This helps reduce magic constants and repetition, as well as making it easier to run the query with different inputs. Here's an example: : { myVariable = 123 } select * from people where id = { myVariable } The following is sent to the underlying database engine: select * from people where id = 123","title":"Preprocessor variables"},{"location":"4.%20General%20topics/Preprocessor/#redirecting-results","text":"The second important task of the preprocessor is redirecting query results into Excel tables and ranges. This can come in very handy for automation. For this purpose QueryStorm's preprocessor provides \" @-directives \". Here's an example: { @ OverdueBooks } select BookName , PersonName from BookRentals where ReturnDate < date () and Returned = 0 Running this query will immediately update the OverdueBooks table in Excel with the results. This saves time if we're working on a query and always writing the results into the same Excel table, but more importantly, it enables automatic update of an Excel table if we embed the query and set up appropriate triggers for executing it (automation).","title":"Redirecting results"},{"location":"4.%20General%20topics/Preprocessor/#multiple-queries-and-redirects","text":"It is possible to have multiple select statements within a query, each one outputting results into a different table or range. Example: @ Table TableName = \"LargestCities\" select * from cities order by population descending limit 10 @ Table TableName = \"SmallestCities\" select * from cities order by population limit 10 Running this query will update two excel tables ( LargestCities and SmallestCities ) in one go. For automation scenarios, this can save time and bandwidth as the same connection (session) can be used to update multiple tables.","title":"Multiple queries and redirects"},{"location":"4.%20General%20topics/Project%20system/","text":"The QueryStorm project system Code files in QueryStorm are organized into projects. Projects contain user code, scripts and configuration files, and are fairly similar to projects in Visual Studio. In order to run the code inside a project, the project needs to be built (compiled). The outputs of the Build process are stored inside the bin folder of the project. The outputs will usually consist of the project dll, the debug and documentation files (pdb + xml docs) and a manifest file that's used by the QueryStorm Runtime. Two types of projects There are two kinds of projects in QueryStorm: Workbook projects and Extension projects. Workbook projects are defined inside a particular workbook and serve to automate the workbook, and to define functions that are specific to the containing workbook. Both the code and as the output files of a workbook project are stored inside the workbook itself. Extension projects are defined at the machine-level, and serve to define functions that should be available in all workbooks. Building (compiling) an extension project produces an extension package. Extension packages can be shared with other users by publishing them to a network share or to an online server. They can be downloaded by end users via the Extensions Manager that's part of the QueryStorm runtime. Supported programming languages QueryStorm projects support source code written in C# and VB.NET. While C# is more popular with developers, VB.NET is more familiar to people with VBA experience. The two languages have a somewhat different syntax, but are practically identical in capabilities. Source code for both languages is compiled using Microsoft's Roslyn compiler. The selected language of the project is defined in the module.config file: \"Language\" : \"CSharp\" The allowed values are \"CSharp\" and \"VisualBasic\". Alternatively, you can use the number 1 (without quotes) for C# and 2 for VB.NET. This setting affects the compilation of the project, as well as the class templates that are used when adding new files to projects. Kinds of files The project system supports the following kinds of files: Class files (.cs or .vb) contain the logic of your application. Depending on the language of the project, they will have a .cs or .vb extension. The Application file ( App.cs/App.vb ) file defines a class that is the entry point of the application and serves to initialize services, the data context and components. There is a maximum of one App file per project. The data context file defines the tables, variables and events that will be visible to scripts and components. On each save, it generates strongly typed classes for accessing the tables defined inside the context. There is a maximum of one data context file per project. Component files are ordinary class files that are generated from a template that provides a skeleton component class. Excel function class files are ordinary class files that are generated from a template that provides an example implementation of a custom Excel function. Script files contain SQL and C# scripts (VB.NET is not supported for scripting) that can process Excel data or fetch data from databases or REST services, or simply run arbitrary code. SQL scripts support a preprocessor syntax that allows defining functions and commands via SQL. Saving a SQL script generates supporting classes that define functions and commands and strongly typed classes for results. The module.config file contains the configuration settings for the project, including a list of library and NuGet references, language selection (CSharp/VisualBasic), connection strings and project metadata (name, version, etc...). Project folders Files can be organized into more-or-less arbitrary folders. The exception are the two folders that have a special meaning, specifically: bin and lib . As mentioned earlier, the bin folder contains the build output of the project. Its contents are cleared before each build, so it should not be used to store any user files. The lib folder contains dll files that were added as library references, as well as dll files that have been downloaded as NuGet packages. All dlls inside this folder are automatically referenced and their types can be used in your code. When publishing a package, the package will contain all files from both the bin and lib folders. Referencing dlls and NuGet packages Projects can use existing libraries in two ways: By installing NuGet packages By referencing local dll files In both cases, dll files are added to the lib folder and are immediately referenced by your project. When referencing a local file, an entry is added to the \"References\" section of the module.config file, while NuGet references are added to the \"Dependencies\" section.","title":"Project system"},{"location":"4.%20General%20topics/Project%20system/#the-querystorm-project-system","text":"Code files in QueryStorm are organized into projects. Projects contain user code, scripts and configuration files, and are fairly similar to projects in Visual Studio. In order to run the code inside a project, the project needs to be built (compiled). The outputs of the Build process are stored inside the bin folder of the project. The outputs will usually consist of the project dll, the debug and documentation files (pdb + xml docs) and a manifest file that's used by the QueryStorm Runtime.","title":"The QueryStorm project system"},{"location":"4.%20General%20topics/Project%20system/#two-types-of-projects","text":"There are two kinds of projects in QueryStorm: Workbook projects and Extension projects. Workbook projects are defined inside a particular workbook and serve to automate the workbook, and to define functions that are specific to the containing workbook. Both the code and as the output files of a workbook project are stored inside the workbook itself. Extension projects are defined at the machine-level, and serve to define functions that should be available in all workbooks. Building (compiling) an extension project produces an extension package. Extension packages can be shared with other users by publishing them to a network share or to an online server. They can be downloaded by end users via the Extensions Manager that's part of the QueryStorm runtime.","title":"Two types of projects"},{"location":"4.%20General%20topics/Project%20system/#supported-programming-languages","text":"QueryStorm projects support source code written in C# and VB.NET. While C# is more popular with developers, VB.NET is more familiar to people with VBA experience. The two languages have a somewhat different syntax, but are practically identical in capabilities. Source code for both languages is compiled using Microsoft's Roslyn compiler. The selected language of the project is defined in the module.config file: \"Language\" : \"CSharp\" The allowed values are \"CSharp\" and \"VisualBasic\". Alternatively, you can use the number 1 (without quotes) for C# and 2 for VB.NET. This setting affects the compilation of the project, as well as the class templates that are used when adding new files to projects.","title":"Supported programming languages"},{"location":"4.%20General%20topics/Project%20system/#kinds-of-files","text":"The project system supports the following kinds of files: Class files (.cs or .vb) contain the logic of your application. Depending on the language of the project, they will have a .cs or .vb extension. The Application file ( App.cs/App.vb ) file defines a class that is the entry point of the application and serves to initialize services, the data context and components. There is a maximum of one App file per project. The data context file defines the tables, variables and events that will be visible to scripts and components. On each save, it generates strongly typed classes for accessing the tables defined inside the context. There is a maximum of one data context file per project. Component files are ordinary class files that are generated from a template that provides a skeleton component class. Excel function class files are ordinary class files that are generated from a template that provides an example implementation of a custom Excel function. Script files contain SQL and C# scripts (VB.NET is not supported for scripting) that can process Excel data or fetch data from databases or REST services, or simply run arbitrary code. SQL scripts support a preprocessor syntax that allows defining functions and commands via SQL. Saving a SQL script generates supporting classes that define functions and commands and strongly typed classes for results. The module.config file contains the configuration settings for the project, including a list of library and NuGet references, language selection (CSharp/VisualBasic), connection strings and project metadata (name, version, etc...).","title":"Kinds of files"},{"location":"4.%20General%20topics/Project%20system/#project-folders","text":"Files can be organized into more-or-less arbitrary folders. The exception are the two folders that have a special meaning, specifically: bin and lib . As mentioned earlier, the bin folder contains the build output of the project. Its contents are cleared before each build, so it should not be used to store any user files. The lib folder contains dll files that were added as library references, as well as dll files that have been downloaded as NuGet packages. All dlls inside this folder are automatically referenced and their types can be used in your code. When publishing a package, the package will contain all files from both the bin and lib folders.","title":"Project folders"},{"location":"4.%20General%20topics/Project%20system/#referencing-dlls-and-nuget-packages","text":"Projects can use existing libraries in two ways: By installing NuGet packages By referencing local dll files In both cases, dll files are added to the lib folder and are immediately referenced by your project. When referencing a local file, an entry is added to the \"References\" section of the module.config file, while NuGet references are added to the \"Dependencies\" section.","title":"Referencing dlls and NuGet packages"}]}