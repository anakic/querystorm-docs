# Automation via SQL

Automation in QueryStorm is usually implemented by writing C# or VB.NET code inside component classes, as described in the previous chapters. However, this code does not necessarily need to be written by hand. SQL scripts can generate the component code automatically, which is especially useful for SQL users who are not familiar with C# and VB.NET.

For this reason (among others) QueryStorm introduces a [preprocessor](todo) for SQL scripts. When setting up automation this way, SQL code is used to fetch data and preprocessor code is used to specify when the script should be executed, and where the results should should be written to (e.g. an Excel table).

## Example

Let's suppose we want to populate an Excel table with sales orders for a given date. When the value of the cell that contains the date changes, we want the script to execute again and to output the new results into the table.

Here's how we might do that:

```sql
{handles orderDate}

{@orders}
select
	*
from
	Sales.SalesOrderHeader soh
where
	OrderDate = @orderDate
```

## Starting the automation

In order to activate the new automation job, the script needs to be saved (`Ctrl+S`), and the project built (`Ctrl+Shift+B`). The component code is generated when the script is saved, and after the build, the runtime loads and activates the workbook application.

## Accessing workbook data

The code in the example assumes that a cell called `orderDate` is defined in the workbook. The variable `@orderDate` that refers to this cell is made available to the script via the data context.

Aside from giving cells names, no other special handling is required in order to be able to reference their values inside scripts.

To allow the workbook to access Excel tables as well, the tables must be included when setting up the script via the "Connect" dialog.

## Outputting query results

The preprocessor allows sending query results into Excel (via the data context). In the example above, the `{@orders}` output directive is used to send the results of the `select` query into an Excel table called `orders`.

The syntax of the output directive is very simple: {@*table_name*} or {output *table_name*}

The output directive should be placed above the select query whose results it should output. If there are multiple select queries in the script, each of them can have its own output directive, so multiple tables can be updated from the same script.

## Trigger events

Specifying events that should trigger execution is another job of the preprocessor. In the example above, we're using the `orderDate` event. For each named cell, an event with the same name is available that activates each time the cell value changes. In the example, using the cell name as the event, means that the script will execute each time the cell's value changes.

To handle the click of an ActiveX button, we should use the following syntax: *sheetName*!*buttonName*, for example `{handles Sheet!CommandButton1}`.

Arbitrarily named events can also be sent from VBA and handled. To send an event from VBA, use the QueryStorm.Runtime.API class:

```vb
CreateObject("QueryStorm.Runtime.API").SendEvent("myEvent")
```

The event can be handled using the preprocessor like so: `{handles myEvent}`

The script can handle multiple events. Event names should be separated by a comma:

```sql
{handles myEvent, orderDate, Sheet1!CommandButton1}

{@orders}
select
    ...
```

## Commands vs functions
``
The preprocessor syntax for declaring an automation command is as follows:

{**handles** *eventsList*}

This is shorthand for:

{**command** *commandName* (*parametersList*) **handles** *eventList*}

The command and [function](todo) declarations are mutually exclusive. A script can either declare a command or a function, but not both.

The functionality in the example looks like it should be implemented as a function that would accept a date parameter and return the query results. If the user's version of Excel supported dynamic arrays, the results could even automatically spill. Additionally, functions don't mess with Excel's undo functionality, which is another advantage for functions.

The drawback of functions, however, is that the data returned from a function isn't an Excel table. The function results cannot be used as the contents of a table, so if you need to do any further processing on the data, the table is a much better place to store the results. Writing to a table can only be done from a command.

For this example, since we're returning data from a database, we could have implemented this functionality either as a function or a command. However, if the script was updating database data rather than simply selecting data from it, implementing it as a command would be the only appropriate choice.
